--CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS "pgcrypto";
--CREATE EXTENSION IF NOT EXISTS "plpython3u";
CREATE EXTENSION IF NOT EXISTS "pg_trgm";

-- CREATE SCHEMA idb4home;
-- CREATE SCHEMA services;

CREATE OR REPLACE FUNCTION drop_db_objects()
    RETURNS boolean
    LANGUAGE 'plpgsql'
    VOLATILE 
AS $BODY$
DECLARE
	sql VARCHAR;
BEGIN
	RAISE NOTICE 'Dropping idb4home database objects...';
	sql := '';
	SELECT string_agg('DROP VIEW IF EXISTS ' || table_name || ' CASCADE;' , E'\n') into sql
	FROM information_schema.tables 
	WHERE table_schema NOT IN ('information_schema','pg_catalog')
	AND table_type = 'VIEW';
	IF sql IS NOT NULL OR sql <> ''
	THEN
		EXECUTE sql;
		RAISE NOTICE 'Done dropping idb4home views!';
	END IF;

	sql := '';
	SELECT string_agg('DROP TABLE IF EXISTS ' || table_name || ' CASCADE;' , E'\n') into sql
	FROM information_schema.tables 
	WHERE table_schema NOT IN ('information_schema','pg_catalog');
	IF sql IS NOT NULL OR sql <> ''
	THEN
		EXECUTE sql;
		RAISE NOTICE 'Done dropping idb4home tables!';
	END IF;		
	
	SELECT string_agg('DROP FUNCTION IF EXISTS ' || pp.proname || '(' || oidvectortypes(pp.proargtypes) || ' ) CASCADE;', E'\n') into sql
	FROM pg_proc pp
	INNER JOIN pg_namespace ns ON (pp.pronamespace = ns.oid)
	INNER JOIN pg_language pl ON (pp.prolang = pl.oid)
	WHERE pl.lanname NOT IN ('c','internal') AND ns.nspname NOT LIKE 'pg_%' AND ns.nspname <> 'information_schema';
	IF sql IS NOT NULL OR sql <> '' THEN
		EXECUTE sql;
		RAISE NOTICE 'Done dropping idb4home functions!';
	END IF;
	RAISE NOTICE 'Done dropping idb4home database objects...';

	-- SELECT string_agg('DROP TYPE IF EXISTS ' || pt.typname || ' CASCADE;', E'\n') into sql
	-- FROM pg_type pt
	-- INNER JOIN pg_namespace ns ON (pt.typnamespace = ns.oid)
	-- WHERE pt.typname NOT LIKE '\_%' AND ns.nspname NOT LIKE 'pg_%' AND ns.nspname <> 'information_schema';
	-- IF sql IS NOT NULL OR sql <> ''
	-- THEN
		-- EXECUTE sql;
		-- RAISE NOTICE 'Done dropping idb4home tables!';
	-- END IF;		
	
	RETURN TRUE;
END;
$BODY$;

COMMENT ON FUNCTION drop_db_objects() IS 'The drop_db_objects function drops drop all tables, views, UDFs associated with idb4home system';

select drop_db_objects();

-- select drop_db_objects();
-- COPY (SELECT * from create_insert_function('module_adapter')) To 'C:\Users\wagdem\Documents\PHD\PHD Files\Projects\idb4home\idb4home\dbschema\misc\result.txt' With CSV;

--######################
--# median
--######################
CREATE OR REPLACE FUNCTION _final_median(anyarray) 
	RETURNS float8 
	LANGUAGE sql
	IMMUTABLE
AS $$ 
	WITH q AS (
		SELECT val
		FROM unnest($1) val
		WHERE VAL IS NOT NULL
		ORDER BY 1
	),
	cnt AS
	(
		SELECT COUNT(*) AS c FROM q
	)
	SELECT AVG(val)::float8
	FROM 
	(
		SELECT val FROM q
		LIMIT  2 - MOD((SELECT c FROM cnt), 2)
		OFFSET GREATEST(CEIL((SELECT c FROM cnt) / 2.0) - 1,0)  
	) q2;
$$;

CREATE AGGREGATE median(anyelement) (
	SFUNC=array_append,
	STYPE=anyarray,
	FINALFUNC=_final_median,
	INITCOND='{}'
);

--######################
--# mode
--######################
CREATE OR REPLACE FUNCTION _final_mode(anyarray) 
	RETURNS anyelement
	LANGUAGE sql
	IMMUTABLE
AS
$$
    SELECT a
    FROM unnest($1) a
    GROUP BY 1 
    ORDER BY COUNT(1) DESC, 1
    LIMIT 1;
$$;
 
CREATE AGGREGATE wom_mode(anyelement) (
  SFUNC=array_append, --Function to call for each row. Just builds the array
  STYPE=anyarray,
  FINALFUNC=_final_mode, --Function to call after everything has been added to array
  INITCOND='{}' --Initialize an empty array when starting
);

--######################
--# select_db_time_stamp_stat
--######################
CREATE OR REPLACE FUNCTION select_db_time_stamp_stat( VARCHAR ) 
	RETURNS TABLE(mu double precision, std double precision)
	LANGUAGE plpgsql 
	VOLATILE
AS $$
BEGIN
	RETURN QUERY
		EXECUTE format('
			SELECT avg(diff), median(diff)
			FROM (
			SELECT EXTRACT(EPOCH FROM (t2.db_time_stamp - t1.db_time_stamp)) AS diff
			FROM %s t1, %s t2
			WHERE t1.sample_id < 5998 and t2.sample_id > 1 and t1.sample_id = t2.sample_id-1) AS tab
		', $1, $1);
END;
$$;


--######################
--# create_insert_function
--######################
CREATE OR REPLACE FUNCTION create_insert_function( tablename varchar )
	RETURNS varchar
	LANGUAGE plpgsql 
	VOLATILE
AS $$
DECLARE
  sql VARCHAR;
  r RECORD;
  params VARCHAR := NULL;
  attributes VARCHAR := NULL;
  attr_values VARCHAR := NULL;
BEGIN
	RAISE NOTICE 'Creating insert function...';
    FOR r IN
		SELECT column_name, data_type
		FROM INFORMATION_SCHEMA.COLUMNS 
		WHERE table_name = tablename and column_name not in ('insert_time_stamp', 'insert_by', 'update_time_stamp', 'update_by')
    LOOP
		IF params IS NULL THEN
			params := 'v_' || r.column_name || ' ' || r.data_type;
			attributes := r.column_name;
			attr_values := 'v_' || r.column_name;
		ELSE
			params := concat_ws(', ', params, 'v_' || r.column_name || ' ' || r.data_type);
			attributes := concat_ws(', ', attributes, r.column_name);
			attr_values := concat_ws(', ', attr_values, 'v_' || r.column_name);
		END IF;
    END LOOP;
	sql := 'CREATE OR REPLACE FUNCTION insert_' || tablename;
	sql := sql || '( ' || params || E' ) \n';
	sql := sql || E'RETURNS boolean \n LANGUAGE PLPGSQL \n AS $BODY$ \n';
	sql := sql || E'BEGIN \n';
	sql := sql || ' INSERT INTO ' || tablename ;
	sql := sql || ' ( ' || attributes || E' ) \n';
	sql := sql || ' VALUES ( ' || attr_values || E' ); \n';
	sql := sql || E' RETURN TRUE; \n';
	sql := sql || E'END; \n';
	sql := sql || E'$BODY$; \n';	
	RAISE NOTICE 'Done creating insert function...';
	RETURN sql;  
END;
$$;
-- COMMENT ON FUNCTION create_insert_function() 
-- IS 'The create_insert_function function creates teh SQL statement for a UDF that is used to insert values into the table given as argument';

select create_insert_function('test');

--######################
--# round_time
--######################
CREATE OR REPLACE FUNCTION round_time(TIMESTAMP WITH TIME ZONE, INTERVAL) 
	RETURNS TIMESTAMP WITH TIME ZONE
	LANGUAGE sql 
	STABLE
AS $$ 
	SELECT date_trunc('hour', $1) + $2 * ROUND(date_part('minute', $1) / 5.0) 
$$;

CREATE OR REPLACE FUNCTION date_round(TIMESTAMP WITH TIME ZONE, INTERVAL) 
	RETURNS TIMESTAMP WITH TIME ZONE
	LANGUAGE sql 
	STABLE
AS $$
	SELECT TO_TIMESTAMP((EXTRACT(epoch FROM $1)::INTEGER + EXTRACT(epoch FROM $2)::INTEGER / 2)
		/ EXTRACT(epoch FROM $2)::INTEGER * EXTRACT(epoch FROM $2)::INTEGER)
$$;


--######################
--# get_sql_stmt_create_trigger
--######################
CREATE OR REPLACE FUNCTION get_sql_stmt_create_trigger( tb_name varchar, tr_name varchar, tr_when varchar, tr_event varchar, tr_condition varchar, func_def varchar)
	RETURNS varchar
	LANGUAGE plpgsql 
	IMMUTABLE	
AS $$
DECLARE
  _sql VARCHAR;
BEGIN
	RAISE NOTICE 'Creating SQL trigger statement...';
	IF to_regclass(tb_name) IS NULL
	THEN
		RAISE EXCEPTION 'Table undefined--> %', tb_name
		USING ERRCODE = '42P01';
	END IF;	
	
	IF tr_name IS NULL OR tr_name = ''
	THEN
		RAISE EXCEPTION 'Invalid identifier: null or empty'
		USING ERRCODE = '22023';
	END IF;
	
	IF NOT (string_to_array(lower(tr_when),',') && string_to_array(lower('before,after'),','))
	THEN
		RAISE EXCEPTION 'Invalid argument to whether the function is called--> %', tr_when
		USING ERRCODE = '22023', HINT = 'The trigger can be specified to fire BEFORE or AFTER the operation';
	END IF;	

	IF NOT (string_to_array(lower(tr_event),',') && string_to_array(lower('insert,update,delete'),','))
	THEN
		RAISE EXCEPTION 'Invalid event--> %', tr_event
		USING ERRCODE = '22023', HINT = 'Events are: INSERT, UPDATE, DELETE';
	END IF;	
	
	IF func_def IS NULL OR func_def = ''
	THEN
		RAISE EXCEPTION 'Invalid function definition string: null or empty'
		USING ERRCODE = '42P13';
	END IF;
	
	IF tr_condition IS NOT NULL AND	tr_condition <> ''
	THEN
		tr_condition := format('WHEN ( %1$s )', tr_condition);
	END IF;

	_sql := format( '
		DROP FUNCTION IF EXISTS %2$I_%3$I_%4$I() CASCADE;
		CREATE OR REPLACE FUNCTION %2$I_%3$I_%4$I()
		RETURNS 
			TRIGGER AS $BODY$
			%6$s
		$BODY$ LANGUAGE PLPGSQL;
	
		DROP TRIGGER IF EXISTS %2$I_%3$I_%4$I ON %1$I;
		CREATE TRIGGER %2$I_%3$I_%4$I 
			%2$I %3$I ON %1$I
			FOR EACH ROW
			%5$s
			EXECUTE PROCEDURE %2$I_%3$I_%4$I();
	', tb_name, tr_when, tr_event, tr_name, tr_condition, func_def); 
	--RAISE NOTICE '%', _sql;
	RAISE NOTICE 'Done creating SQL trigger statement...';
	RETURN _sql;  
END;
$$;

--######################
--# hex_to_int
--######################
CREATE OR REPLACE FUNCTION hex2int(hexval varchar) 
	RETURNS integer
	LANGUAGE plpgsql 
	IMMUTABLE STRICT	
AS $$
DECLARE
  _result  int;
BEGIN
  EXECUTE 'SELECT x' || quote_literal(hexval) || '::int' INTO _result;
  RETURN _result;
END;
$$;

DROP TYPE IF EXISTS status_type CASCADE;

CREATE TYPE status_type AS ENUM (
	'Available',
	'Error',
	'Executing',
	'Not Available',
	'Started',
	'Stopped',
	'Unknown'
);

CREATE OR REPLACE FUNCTION create_resource_db_objects( v_uuid uuid, v_model_uuid uuid ) 
	RETURNS boolean
	LANGUAGE plpgsql
	VOLATILE
AS $$
DECLARE
	_tablename varchar;
	_tableattr jsonb;
	_attributes jsonb;  
BEGIN
	RAISE NOTICE 'Creating % table (s) and function (s)...', v_uuid::varchar;
	SELECT attributes INTO _attributes
	FROM resource_model
	WHERE resource_model_id = v_model_uuid;
	
	IF jsonb_array_length(_attributes) = 1
	THEN
		PERFORM create_resource_table(replace(v_uuid::varchar, '-', ''), _attributes#>>'{0, attributes}');
		PERFORM create_resource_insert_function(replace(v_uuid::varchar, '-', ''));
	ELSE
		FOR _tableattr IN SELECT * FROM jsonb_array_elements(_attributes)
		LOOP
			_tablename := replace(v_uuid::varchar, '-', '');
			IF _tableattr->>'table_sufix' != '' THEN
			_tablename = format('%I_%I', _tablename, _tableattr->>'table_sufix');
			END IF;
			PERFORM create_resource_table(_tablename, _tableattr::jsonb#>>'{attributes, 0}');
			PERFORM create_resource_insert_function(_tablename);
		END LOOP;
	END IF;	
	RAISE NOTICE 'Done creating % table (s) and function (s)...', v_uuid::varchar;
	RETURN TRUE;  
END;
$$;

DROP FUNCTION IF EXISTS delete_resource_db_objects( uuid );
CREATE OR REPLACE FUNCTION delete_resource_db_objects( uuid )
	RETURNS boolean
	LANGUAGE plpgsql 
	VOLATILE
AS $$
BEGIN
	PERFORM drop_resource_after_insert_trigger( $1 );
	PERFORM drop_resource_functions( $1 );
	PERFORM drop_resource_table( $1 );	
	RETURN TRUE;   
END;
$$;

CREATE OR REPLACE FUNCTION generate_uuid() 
	RETURNS uuid 
	LANGUAGE plpgsql 
	VOLATILE
AS $$
BEGIN
    RETURN OVERLAY(REPLACE(gen_random_uuid()::varchar, '-', '') placing 'a' FROM 1)::uuid;
END;
$$;


CREATE OR REPLACE FUNCTION select_dbca_uuid() 
	RETURNS uuid 
	LANGUAGE plpgsql 
	VOLATILE
AS $$
DECLARE 
	_uuid uuid;		
BEGIN
	IF NOT EXISTS (
		SELECT 1
		FROM information_schema.tables 
		WHERE table_schema = 'public'
		AND table_name = 'db_uuid'
		) THEN
			--CREATE TABLE db_uuid AS SELECT OVERLAY(OVERLAY(REPLACE(gen_random_uuid()::varchar, '-', '') placing 'dbca0000' FROM 1) placing '00000000dbca' FROM 21)::uuid as db_uuid;
			CREATE TABLE db_uuid AS SELECT 'dbca0000-666e-4897-ada6-00000000dbca'::uuid as db_uuid;
	END IF;
	SELECT db_uuid INTO _uuid
	FROM db_uuid;
	RETURN _uuid;
END;
$$;

select select_dbca_uuid();

CREATE OR REPLACE FUNCTION select_global_channel() 
	RETURNS varchar 
	LANGUAGE sql
AS 
$$
	SELECT REPLACE(select_dbca_uuid()::varchar, '-', '')
$$;

DROP FUNCTION IF EXISTS create_resource_after_insert_trigger( v_uuid uuid, v_code text );
CREATE OR REPLACE FUNCTION create_resource_after_insert_trigger( v_uuid uuid, v_code text )
	RETURNS boolean
	LANGUAGE plpgsql 
	VOLATILE
AS $$
DECLARE
  _uuid varchar := replace(v_uuid::varchar, '-', '');
BEGIN
	EXECUTE format(	'
	CREATE OR REPLACE FUNCTION after_insert_%1$I() 
	RETURNS TRIGGER AS $BODY$ 
	%2$s 
	$BODY$ LANGUAGE PLPGSQL;
	', _uuid, v_code);					
	EXECUTE get_create_trigger_after_insert_stmnt( _uuid, '');
	RETURN TRUE;  
END;
$$;
DROP FUNCTION IF EXISTS create_resource_insert_function( v_name text );
CREATE OR REPLACE FUNCTION create_resource_insert_function( v_name text )
	RETURNS boolean
	LANGUAGE plpgsql 
	VOLATILE
AS $$
DECLARE
  sql VARCHAR;
  r RECORD;
  params VARCHAR;
  attributes VARCHAR;
  attr_values VARCHAR;
BEGIN
	params := '';
	attributes := '';
	attr_values := '';
    FOR r IN
		SELECT column_name, data_type
		FROM INFORMATION_SCHEMA.COLUMNS 
		WHERE table_name = v_name and column_name not in ('sample_id', 'dev_time_stamp', 'host_time_stamp', 'db_time_stamp')
    LOOP
        params := params || 'v_' || r.column_name || ' ' || r.data_type || ', ';
		attributes := attributes || r.column_name || ', ';
		attr_values := attr_values || 'v_' || r.column_name || ', ';
    END LOOP;
	sql := 'CREATE FUNCTION insert_' || v_name;
	sql := sql || '( ';
	sql := sql || params;
	sql := sql || ' v_dev_ts timestamptz, v_host_ts timestamptz) ';
	sql := sql || ' RETURNS bool AS $BODY$ ';
	sql := sql || ' BEGIN ';
	sql := sql || ' INSERT INTO ' || v_name;
	sql := sql || ' ( ';
	sql := sql || attributes;
	sql := sql || ' dev_time_stamp, host_time_stamp ) ';
	sql := sql || ' VALUES ( ';
	sql := sql || attr_values;
	sql := sql || ' v_dev_ts, v_host_ts); ';
	sql := sql || ' RETURN TRUE; ';
	sql := sql || ' END; ';
	sql := sql || ' $BODY$ LANGUAGE PLPGSQL; ';	
	EXECUTE sql;
	RETURN TRUE;  
END;
$$;

DROP FUNCTION IF EXISTS create_resource_table( v_name text, v_attributes text);
CREATE OR REPLACE FUNCTION create_resource_table( v_name text, v_attributes text) 
	RETURNS boolean
	LANGUAGE plpgsql
	VOLATILE
AS $$
BEGIN
	EXECUTE format(	'CREATE TABLE %I(
					--sample_id serial PRIMARY KEY,
					%s,
					dev_time_stamp timestamptz NOT NULL DEFAULT clock_timestamp(),
					host_time_stamp timestamptz NOT NULL DEFAULT clock_timestamp(),
					db_time_stamp timestamptz PRIMARY KEY NOT NULL DEFAULT clock_timestamp() 
					);', v_name, v_attributes );
	RETURN TRUE;  
END;
$$;


DROP FUNCTION IF EXISTS drop_resource_after_insert_trigger( uuid );
CREATE OR REPLACE FUNCTION drop_resource_after_insert_trigger( uuid )
	RETURNS boolean
	LANGUAGE plpgsql 
	VOLATILE
AS $$
DECLARE
  _uuid VARCHAR := replace($1::varchar, '-', '');
BEGIN	
	EXECUTE format(	'DROP TRIGGER IF EXISTS after_insert_%I ON %I ;', _uuid, _uuid);
	EXECUTE format(	'DROP FUNCTION IF EXISTS after_insert_%I() ;', _uuid);
	RETURN TRUE;  
END;
$$;


DROP FUNCTION IF EXISTS drop_resource_functions( uuid );
CREATE OR REPLACE FUNCTION drop_resource_functions( uuid )
	RETURNS boolean
	LANGUAGE plpgsql
	VOLATILE	
AS $$
DECLARE
  sql VARCHAR;
BEGIN
	SELECT string_agg('DROP FUNCTION IF EXISTS ' || proname || '(' || oidvectortypes(proargtypes) || ' ) CASCADE;', E'\n') into sql
	FROM pg_proc INNER JOIN pg_namespace ns ON (pg_proc.pronamespace = ns.oid)
	WHERE ns.nspname = 'public' and proname like '%' || replace($1::varchar, '-', '');
	EXECUTE sql; 	
	RETURN TRUE;   
END;
$$;


DROP FUNCTION IF EXISTS drop_resource_insert_function( uuid );
CREATE OR REPLACE FUNCTION drop_resource_insert_function( uuid )
	RETURNS boolean
	LANGUAGE plpgsql 
	VOLATILE
AS $$
DECLARE
	sql VARCHAR;
BEGIN
	SELECT string_agg('DROP FUNCTION IF EXISTS ' || proname || '(' || oidvectortypes(proargtypes) || ' ) CASCADE;', E'\n') into sql
	FROM pg_proc INNER JOIN pg_namespace ns ON (pg_proc.pronamespace = ns.oid)
	WHERE ns.nspname = 'public' and proname = format('insert_%I', replace($1::varchar, '-', ''));
	EXECUTE sql; 
	
	RETURN TRUE;   
END;
$$;



DROP FUNCTION IF EXISTS drop_resource_table( uuid );
CREATE OR REPLACE FUNCTION drop_resource_table( uuid ) 
	RETURNS boolean
	LANGUAGE plpgsql 
	VOLATILE
AS $$
BEGIN
	EXECUTE format(	'DROP TABLE IF EXISTS %I ;', replace(v_uuid::varchar, '-', ''));
	RETURN TRUE;  
END;
$$;



DROP TABLE IF EXISTS country CASCADE;

CREATE TABLE country
(
	country_id						serial PRIMARY KEY UNIQUE,
	country							text,
	insert_time_stamp				timestamptz NOT NULL DEFAULT clock_timestamp(),	
	insert_by						text NOT NULL DEFAULT CURRENT_USER,
	update_time_stamp				timestamptz NOT NULL DEFAULT clock_timestamp(),
	update_by						text NOT NULL DEFAULT CURRENT_USER
);

DROP FUNCTION IF EXISTS select_country_id_by_country( v_country varchar );
CREATE OR REPLACE FUNCTION select_country_id_by_country( v_country varchar )
	RETURNS integer 
	LANGUAGE plpgsql
	VOLATILE
AS $$
DECLARE 
	_id integer;
BEGIN
	SELECT country_id INTO STRICT _id
    FROM country
	WHERE LOWER(country) LIKE '%'|| LOWER(v_country) || '%';
	RETURN _id;
EXCEPTION
	WHEN NO_DATA_FOUND THEN
		RAISE EXCEPTION 'No Country with name %.', v_country;
	WHEN TOO_MANY_ROWS THEN
		RAISE EXCEPTION 'Ccountry with name % not unique.', v_country;
END;
$$;

INSERT INTO country ( country ) 
VALUES 
	('Afghanistan'),
	('Algeria'),
	('American Samoa'),
	('Angola'),
	('Anguilla'),
	('Argentina'),
	('Armenia'),
	('Australia'),
	('Austria'),
	('Azerbaijan'),
	('Bahrain'),
	('Bangladesh'),
	('Belarus'),
	('Bolivia'),
	('Brazil'),
	('Brunei'),
	('Bulgaria'),
	('Cambodia'),
	('Cameroon'),
	('Canada'),
	('Chad'),
	('Chile'),
	('China'),
	('Colombia'),
	('Congo, The Democratic Republic of the'),
	('Czech Republic'),
	('Dominican Republic'),
	('Ecuador'),
	('Egypt'),
	('Estonia'),
	('Ethiopia'),
	('Faroe Islands'),
	('Finland'),
	('France'),
	('French Guiana'),
	('French Polynesia'),
	('Gambia'),
	('Germany'),
	('Greece'),
	('Greenland'),
	('Holy See (Vatican City State)'),
	('Hong Kong'),
	('Hungary'),
	('India'),
	('Indonesia'),
	('Iran'),
	('Iraq'),
	('Israel'),
	('Italy'),
	('Japan'),
	('Kazakstan'),
	('Kenya'),
	('Kuwait'),
	('Latvia'),
	('Liechtenstein'),
	('Lithuania'),
	('Madagascar'),
	('Malawi'),
	('Malaysia'),
	('Mexico'),
	('Moldova'),
	('Morocco'),
	('Mozambique'),
	('Myanmar'),
	('Nauru'),
	('Nepal'),
	('Netherlands'),
	('New Zealand'),
	('Nigeria'),
	('North Korea'),
	('Oman'),
	('Pakistan'),
	('Paraguay'),
	('Peru'),
	('Philippines'),
	('Poland'),
	('Puerto Rico'),
	('Romania'),
	('Runion'),
	('Russian Federation'),
	('Saint Vincent and the Grenadines'),
	('Saudi Arabia'),
	('Senegal'),
	('Slovakia'),
	('South Africa'),
	('South Korea'),
	('Spain'),
	('Sri Lanka'),
	('Sudan'),
	('Sweden'),
	('Switzerland'),
	('Taiwan'),
	('Tanzania'),
	('Thailand'),
	('Tonga'),
	('Tunisia'),
	('Turkey'),
	('Turkmenistan'),
	('Tuvalu'),
	('Ukraine'),
	('United Arab Emirates'),
	('United Kingdom'),
	('United States'),
	('Venezuela'),
	('Vietnam'),
	('Virgin Islands, U.S.'),
	('Yemen'),
	('Yugoslavia'),
	('Zambia')
;

DROP TABLE IF EXISTS city CASCADE;

CREATE TABLE city
(
	city_id							serial PRIMARY KEY UNIQUE,
	city							text,
	country_id						integer REFERENCES country (country_id) ON DELETE RESTRICT ON UPDATE CASCADE,
	insert_time_stamp				timestamptz NOT NULL DEFAULT clock_timestamp(),	
	insert_by						text NOT NULL DEFAULT CURRENT_USER,
	update_time_stamp				timestamptz NOT NULL DEFAULT clock_timestamp(),
	update_by						text NOT NULL DEFAULT CURRENT_USER
);

DROP FUNCTION IF EXISTS select_city_id_by_city( v_city varchar );
CREATE OR REPLACE FUNCTION select_city_id_by_city( v_city varchar )
	RETURNS integer 
	LANGUAGE plpgsql
	VOLATILE
AS $$
DECLARE 
	_id integer;
BEGIN
	SELECT city_id INTO STRICT _id
    FROM city
	WHERE LOWER(city) LIKE '%'|| LOWER(v_city) || '%';
	RETURN _id;
EXCEPTION
	WHEN NO_DATA_FOUND THEN
		RAISE EXCEPTION 'No city with name %.', v_city;
	WHEN TOO_MANY_ROWS THEN
		RAISE EXCEPTION 'Ccity with name % not unique.', v_city;
END;
$$;

INSERT INTO city ( city, country_id ) 
VALUES ('Halmstad', select_country_id_by_country('sweden'));

DROP TABLE IF EXISTS address CASCADE;

CREATE TABLE address
(
	address_id						uuid PRIMARY KEY UNIQUE DEFAULT generate_uuid(),
	address							text NOT NULL,
	district						text,
	postal_code 					character varying(10),
	city_id							integer REFERENCES country (country_id) ON DELETE RESTRICT ON UPDATE CASCADE,
	insert_time_stamp				timestamptz NOT NULL DEFAULT clock_timestamp(),	
	insert_by						text NOT NULL DEFAULT CURRENT_USER,
	update_time_stamp				timestamptz NOT NULL DEFAULT clock_timestamp(),
	update_by						text NOT NULL DEFAULT CURRENT_USER
);

CREATE OR REPLACE FUNCTION insert_address( v_address text, v_district text, v_postal_code character varying, v_city character varying ) 
	RETURNS boolean
	LANGUAGE plpgsql 
	VOLATILE
AS $$
BEGIN 
	INSERT INTO address ( address, district, postal_code, city_id ) 
	VALUES ( v_address, v_district, v_postal_code, select_city_id_by_city(v_city) ); 
	RETURN TRUE; 
END; 
$$;


DROP FUNCTION IF EXISTS select_address_id_by_address( v_address varchar );
CREATE OR REPLACE FUNCTION select_address_id_by_address( v_address varchar )
	RETURNS uuid 
	LANGUAGE plpgsql
	VOLATILE
AS $$
DECLARE 
	_id uuid;
BEGIN
	SELECT address_id INTO STRICT _id
    FROM address
	WHERE LOWER(address) LIKE '%'|| LOWER(v_address) || '%';
	RETURN _id;
EXCEPTION
	WHEN NO_DATA_FOUND THEN
		RAISE EXCEPTION 'No address with name %.', v_address;
	WHEN TOO_MANY_ROWS THEN
		RAISE EXCEPTION 'Caddress with name % not unique.', v_address;
END;
$$;

select insert_address ('Kristian IV:s v√§g 3', 'Nyhem', '30118', 'Halmstad');




DROP TABLE IF EXISTS environment CASCADE;

CREATE TABLE environment
(
	environment_id					uuid PRIMARY KEY UNIQUE DEFAULT generate_uuid(),
	name							text,
	description						text DEFAULT '',
	no_floors						numeric DEFAULT 1,
	address_id						uuid REFERENCES address (address_id) ON DELETE RESTRICT ON UPDATE CASCADE,
	insert_time_stamp				timestamptz NOT NULL DEFAULT clock_timestamp(),	
	insert_by						text NOT NULL DEFAULT CURRENT_USER,
	update_time_stamp				timestamptz NOT NULL DEFAULT clock_timestamp(),
	update_by						text NOT NULL DEFAULT CURRENT_USER
);

CREATE OR REPLACE FUNCTION insert_environment( v_name character varying,v_description text,v_no_floors numeric , v_address character varying) 
	RETURNS boolean
	LANGUAGE plpgsql 
	VOLATILE
AS $$
BEGIN 
	INSERT INTO environment ( name, description, no_floors, address_id ) 
	VALUES ( v_name, v_description, v_no_floors, select_address_id_by_address(v_address) ); 
	RETURN TRUE; 
END; 
$$;

DROP FUNCTION IF EXISTS select_environment_id_by_name( v_name varchar );
CREATE OR REPLACE FUNCTION select_environment_id_by_name( v_name varchar )
	RETURNS uuid
	LANGUAGE plpgsql 
	VOLATILE
AS $$
DECLARE 
	_id uuid;
BEGIN
	SELECT environment_id INTO STRICT _id
    FROM environment
	WHERE LOWER(name) LIKE '%'|| LOWER(v_name) || '%';
	RETURN _id;
EXCEPTION
	WHEN NO_DATA_FOUND THEN
		RAISE EXCEPTION 'No Environment with name %.', v_name;
	WHEN TOO_MANY_ROWS THEN
		RAISE EXCEPTION 'Environment with name % not unique.', v_name;
END;
$$;

DROP TABLE IF EXISTS host CASCADE;

CREATE TABLE host
(
	host_id							uuid PRIMARY KEY UNIQUE DEFAULT generate_uuid(),
	name							text,
	description						text DEFAULT '',
	ip								inet DEFAULT NULL,
	insert_time_stamp				timestamptz NOT NULL DEFAULT clock_timestamp(),	
	insert_by						text NOT NULL DEFAULT CURRENT_USER,
	update_time_stamp				timestamptz NOT NULL DEFAULT clock_timestamp(),
	update_by						text NOT NULL DEFAULT CURRENT_USER
);

CREATE OR REPLACE FUNCTION insert_host( v_name character varying,v_description text,v_ip inet ) 
	RETURNS bool
	LANGUAGE plpgsql 
	VOLATILE	
AS $$ 
BEGIN 
	INSERT INTO host ( name,description,ip ) 
	VALUES ( v_name,v_description,v_ip ); 
	RETURN TRUE; 
END; 
$$;

DROP FUNCTION IF EXISTS select_host_id_by_name( v_name varchar );
CREATE OR REPLACE FUNCTION select_host_id_by_name( v_name varchar )
	RETURNS uuid
	LANGUAGE plpgsql 
	VOLATILE	
AS $$
DECLARE 
	_id uuid;
BEGIN
	SELECT host_id INTO STRICT _id
    FROM host
	WHERE LOWER(name) LIKE '%'|| LOWER(v_name) || '%';
	RETURN _id;
EXCEPTION
	WHEN NO_DATA_FOUND THEN
		RAISE EXCEPTION 'No host with name %.', v_name;
	WHEN TOO_MANY_ROWS THEN
		RAISE EXCEPTION 'host with name % not unique.', v_name;
END;
$$;

DROP TABLE IF EXISTS room_type CASCADE;

CREATE TABLE room_type
(
	room_type_id					uuid PRIMARY KEY UNIQUE DEFAULT generate_uuid(), 
	name 							text,
	description						text DEFAULT '',
	insert_time_stamp				timestamptz NOT NULL DEFAULT clock_timestamp(),	
	insert_by						text NOT NULL DEFAULT CURRENT_USER,
	update_time_stamp				timestamptz NOT NULL DEFAULT clock_timestamp(),
	update_by						text NOT NULL DEFAULT CURRENT_USER
);

CREATE OR REPLACE FUNCTION insert_room_type( v_name character varying,v_description text ) 
	RETURNS bool
	LANGUAGE plpgsql 
	VOLATILE	
AS $$
BEGIN 
	INSERT INTO room_type ( name, description ) 
	VALUES ( v_name, v_description ); 
	RETURN TRUE; 
END; 
$$;

DROP FUNCTION IF EXISTS select_room_type_id_by_name( v_name varchar );
CREATE OR REPLACE FUNCTION select_room_type_id_by_name( v_name varchar )
	RETURNS uuid
	LANGUAGE plpgsql 
	VOLATILE	
AS $$
DECLARE 
	_id uuid;
BEGIN
	SELECT room_type_id INTO STRICT _id
    FROM room_type
	WHERE LOWER(name) LIKE '%'|| LOWER(v_name) || '%';
	RETURN _id;
EXCEPTION
	WHEN NO_DATA_FOUND THEN
		RAISE EXCEPTION 'No Room Type with name %.', v_name;
	WHEN TOO_MANY_ROWS THEN
		BEGIN
			SELECT room_type_id INTO STRICT _id
			FROM room_type
			WHERE name = v_name;
			RETURN _id;
		EXCEPTION
			WHEN NO_DATA_FOUND THEN
				RAISE EXCEPTION 'No Room Type with name %.', v_name;
			WHEN TOO_MANY_ROWS THEN
				RAISE EXCEPTION 'Room Type with name % not unique.', v_name;
		END;
END;
$$;

INSERT INTO room_type ( room_type_id, name ) 
VALUES
  ('a20141a69f584876b65fe2aa9bbe6185'::uuid, 'Attic'),
  ('ad8cf14a00964015bacfabfabee6a99f'::uuid, 'Balcony'),
  ('a71b07776e3648529773c3bf75d26d7c'::uuid, 'Bathroom'),
  ('a91bfa17013f4f49a1b7dc2a0e5e6b0e'::uuid, 'Bedroom'),
  ('a57db6f9fe3b4ec1bf2c08c6ab2a967a'::uuid, 'Cellar'),
  ('a7e84800cf5346198fe82d815d3d965c'::uuid, 'Closet'),
  ('afe6e9d4629e4f518218b7aa073e677d'::uuid, 'Conservatory'),
  ('a386aa7e759f48389664a72957b4ccef'::uuid, 'Corridor'),
  ('a829804958b44fbeb7834d3b63ebf048'::uuid, 'Dining room'),
  ('a9f8df5236e3471fbb09948afde4b043'::uuid, 'Entrance'),
  ('ab88b9fc9b0e4b7b836fb7d485bcc504'::uuid, 'Furnace room'),
  ('a660e0c6865f4e879a0934904541e0b8'::uuid, 'Garage'),
  ('a3eef5e9ef084badae9e179ce6b5cc96'::uuid, 'Guest room'),
  ('adca12ffa6bd494a9910e1d34e76563f'::uuid, 'Hall'),
  ('ac4046431dc44ee5b5394c6e1464ec9e'::uuid, 'Kitchen'),
  ('a365adbbd182452ba50e42783b23b972'::uuid, 'Living room'),
  ('abcd801eb14544f9ae51a133096df93f'::uuid, 'Loundry room'),
  ('a07e329e6bd84aeb981e68072daee27e'::uuid, 'Master bedroom'),
  ('a8802135ce4e441886dab1c62e12b2f6'::uuid, 'Music room'),
  ('a8bec5bf67894dd48e6a529e4520547a'::uuid, 'Playroom'),
  ('aaf3e21497554b94b658cce9986cd746'::uuid, 'Porch'),
  ('aa870009f7274cbf88a032b88787a6b0'::uuid, 'Home office'),
  ('a88dc14866a047308a3c7cdb3518b683'::uuid, 'Sauna'),
  ('a67a25596fb64d04891f81f2ba6ec77c'::uuid, 'Server room'),
  ('a5fde5c745534ce59110b74d68fecd03'::uuid, 'Stairway'),
  ('a28e8154f1a14727b33d0b0aa3ef8b8c'::uuid, 'Study room'),
  ('a9b8fd4265494636ace71eb1edb8fc0e'::uuid, 'Toilet'),
  ('a2b09a0a237644d8aee57baf3c86e5e6'::uuid, 'Vestibule'),
  ('a853cdfa54af4d65a3da1c2e5e507b91'::uuid, 'Workshop')
;DROP TABLE IF EXISTS floor_type CASCADE;

CREATE TABLE floor_type
(
	floor_type_id					uuid PRIMARY KEY UNIQUE DEFAULT generate_uuid(),
	name							text,
	description						text DEFAULT '',
	insert_time_stamp				timestamptz NOT NULL DEFAULT clock_timestamp(),	
	insert_by						text NOT NULL DEFAULT CURRENT_USER,
	update_time_stamp				timestamptz NOT NULL DEFAULT clock_timestamp(),
	update_by						text NOT NULL DEFAULT CURRENT_USER
);

CREATE OR REPLACE FUNCTION insert_floor_type( v_name character varying,v_description text ) 
	RETURNS boolean
	LANGUAGE plpgsql 
	VOLATILE	
AS $$
BEGIN 
 INSERT INTO floor_type ( name,description ) 
 VALUES ( v_name,v_description ); 
 RETURN TRUE; 
END; 
$$;

DROP FUNCTION IF EXISTS select_floor_type_id_by_name( v_name varchar );
CREATE OR REPLACE FUNCTION select_floor_type_id_by_name( v_name varchar )
	RETURNS uuid
	LANGUAGE plpgsql 
	VOLATILE	
AS $$
DECLARE 
	_id uuid;
BEGIN
	SELECT floor_type_id INTO STRICT _id
    FROM floor_type
	WHERE LOWER(name) LIKE '%'|| LOWER(v_name) || '%';
	RETURN _id;
EXCEPTION
	WHEN NO_DATA_FOUND THEN
		RAISE EXCEPTION 'No Floor Type with name %.', v_name;
	WHEN TOO_MANY_ROWS THEN
		BEGIN
			SELECT floor_type_id INTO STRICT _id
			FROM floor_type
			WHERE name = v_name;
			RETURN _id;
		EXCEPTION
			WHEN NO_DATA_FOUND THEN
				RAISE EXCEPTION 'No Floor Type with name %.', v_name;
			WHEN TOO_MANY_ROWS THEN
				RAISE EXCEPTION 'Floor Type with name % not unique.', v_name;
		END;
END;
$$;

INSERT INTO floor_type ( floor_type_id, name, description ) 
VALUES
	('a7b9a7c43d6d40d280d1b558793ea377'::uuid, 'Basement', 'Basement'),
	('affa4b35fc3d4d378c50c1db02d1edba'::uuid, 'Ground floor', '1st floor in US'),
	('af1e9380e72b4c8aac011f275ef7efa4'::uuid, 'First floor', '2nd floor in US'),
	('a6f7d26544f14eb7b7aab36e0dabe58c'::uuid, 'Second floor', '3nd floor in US'),
	('a3ac67aff5ee4258961d0d0d1ec341f7'::uuid, 'Roof', 'Roof')
;DROP TABLE IF EXISTS room CASCADE;

CREATE TABLE room
(
	room_id							uuid PRIMARY KEY UNIQUE DEFAULT generate_uuid(), 
	environment_id					uuid REFERENCES environment (environment_id) ON DELETE RESTRICT ON UPDATE CASCADE,
	room_type_id					uuid REFERENCES room_type (room_type_id) ON DELETE RESTRICT ON UPDATE CASCADE,
	floor_type_id					uuid REFERENCES floor_type (floor_type_id) ON DELETE RESTRICT ON UPDATE CASCADE,
	name							text,
	description						text DEFAULT '',
	insert_time_stamp				timestamptz NOT NULL DEFAULT clock_timestamp(),	
	insert_by						text NOT NULL DEFAULT CURRENT_USER,
	update_time_stamp				timestamptz NOT NULL DEFAULT clock_timestamp(),
	update_by						text NOT NULL DEFAULT CURRENT_USER
);

CREATE OR REPLACE FUNCTION insert_room( v_environment_id uuid,v_room_type_id integer,v_floor_type_id integer,v_name character varying,v_description text ) 
	RETURNS boolean
	LANGUAGE plpgsql 
	VOLATILE	
AS $$
BEGIN 
 INSERT INTO room ( environment_id,room_type_id,floor_type_id,name,description ) 
 VALUES ( v_environment_id,v_room_type_id,v_floor_type_id,v_name,v_description ); 
 RETURN TRUE; 
END; 
$$;

DROP FUNCTION IF EXISTS select_room_id_by_name( v_name varchar );
CREATE OR REPLACE FUNCTION select_room_id_by_name( v_name varchar )
	RETURNS uuid
	LANGUAGE plpgsql 
	VOLATILE	
AS $$
DECLARE 
	_id uuid;
BEGIN
	SELECT room_id INTO STRICT _id
    FROM room
	WHERE LOWER(name) LIKE '%'|| LOWER(v_name) || '%';
	RETURN _id;
EXCEPTION
	WHEN NO_DATA_FOUND THEN
		RAISE EXCEPTION 'No Room with name %.', v_name;
	WHEN TOO_MANY_ROWS THEN
		RAISE EXCEPTION 'Room with name % not unique.', v_name;
END;
$$;


DROP TABLE IF EXISTS module_adapter CASCADE;

CREATE TABLE module_adapter
(
	module_adapter_id				uuid PRIMARY KEY UNIQUE DEFAULT generate_uuid(),
	name							text,
	description						text DEFAULT '',
	insert_time_stamp				timestamptz NOT NULL DEFAULT clock_timestamp(),	
	insert_by						text NOT NULL DEFAULT CURRENT_USER,
	update_time_stamp				timestamptz NOT NULL DEFAULT clock_timestamp(),
	update_by						text NOT NULL DEFAULT CURRENT_USER
);

CREATE OR REPLACE FUNCTION insert_module_adapter( v_name character varying,v_description text ) 
	RETURNS boolean
	LANGUAGE plpgsql 
	VOLATILE	
AS $$
BEGIN 
	INSERT INTO module_adapter ( name,description ) 
	VALUES ( v_name,v_description ); 
	RETURN TRUE; 
END; 
$$;

DROP FUNCTION IF EXISTS select_module_adapter_id_by_name( v_name varchar );
CREATE OR REPLACE FUNCTION select_module_adapter_id_by_name( v_name varchar )
	RETURNS uuid
	LANGUAGE plpgsql 
	VOLATILE	
AS $$
DECLARE 
	_id uuid;
BEGIN
	SELECT module_adapter_id INTO STRICT _id
    FROM module_adapter
	WHERE LOWER(name) LIKE '%'|| LOWER(v_name) || '%';
	RETURN _id;
EXCEPTION
	WHEN NO_DATA_FOUND THEN
		RAISE EXCEPTION 'No Module Adapter with name %.', v_name;
	WHEN TOO_MANY_ROWS THEN
		RAISE EXCEPTION 'Module Adapter with name % not unique.', v_name;
END;
$$;

INSERT INTO module_adapter ( module_adapter_id, name ) 
VALUES 
  ('ad0aa1e783f747e28360ce935e2dfe96'::uuid, 'ti.TI_ADS1232REF_Weight_Scale'), 
  ('ad145dc332254c9493133f9f39a7a372'::uuid, 'axis.Axis_m1013w_Network_Camera'), 
  ('ad25584d35e14f2cb1f13f827c7303c6'::uuid, 'vti.sca3000_Accelerometer'), 
  ('ad28e15351ad485594836fda9f36da5d'::uuid, 'emfit.Emfit_Bed_L_4060s'), 
  ('ad4c4ea113c645ba97f21eac43bbf3be'::uuid, 'esic.ESIC_WT450H_Temperatue_Humidity'), 
  ('ad5aca8b5974423e9618126978fb4018'::uuid, 'everflourish.Everflourish_EMW200RA_Switch_Receiver'),
  ('ad5da959e3ba44ab9950e1decf70b5ff'::uuid, 'nexa.Nexa_EYCR_200_Dimmer_Receiver'), 
  ('ad876a908572443fbd30a68eb6d00d77'::uuid, 'nexa.Nexa_EYCR_2300_Switch_Receiver'), 
  ('ad8e72b20b314c1581587b486654b066'::uuid, 'nexa.Nexa_NEYCR_1500_Switch_Receiver'), 
  ('ad93da2abc8042418947048e5c2da8e6'::uuid, 'nexa.Nexa_EYCR_250_Dimmer_Receiver'), 
  ('adabec3c9f2740db959485469f7d5c9f'::uuid, 'nexa.Nexa_LDR_911_Led_White'), 
  ('adb5016c591b4be2bf2b2fed62a6212d'::uuid, 'nexa.Nexa_LDR_911A_Led_Black'), 
  ('adcc4601bd2f43d4b3d868978c5d11a1'::uuid, 'nexa.Nexa_LMDT_609_PIR'), 
  ('add74d5c3a9644568a5de18c1a04ad48'::uuid, 'nexa.Nexa_LMDT_810_OUT_PIR'), 
  ('add7f2f635314f40821ae1cf5b655d2d'::uuid, 'nexa.Nexa_LMLT_711_Push_Button'), 
  ('add8c3365fcd4579b1e5ea5c60782676'::uuid, 'nexa.Nexa_LMST_606_Magnet'), 
  ('adda34eeb6bd4ec6b7c85418a1b372c2'::uuid, 'nexa.Nexa_LWST_605_2Ch_Wall_Switch_Transmiter'), 
  ('adde03b20a8c4ab5954474ff286fdd49'::uuid, 'nexa.Nexa_LWST_615_1Ch_Wall_Switch_Transmiter'), 
  ('ae14556e5b614f1ba4f8a68b5a32148e'::uuid, 'nexa.Nexa_LYCT_802_Remote_Control'), 
  ('ae168d080f6946bfbe50dbf9597a8aa8'::uuid, 'nexa.Nexa_MLR_1105_Door_Bell'), 
  ('ae2718ba0243408e80956a37bfe2cb11'::uuid, 'nexa.Nexa_LMLR_710_Door_Bell'), 
  ('ae4379c5e950453da5f790590aa2f66d'::uuid, 'nexa.Nexa_NEYCT_705_Remote_Control'), 
  ('ae4a365e8b11418b8b3b3b3f8db380f4'::uuid, 'nexa.Nexa_WMR_252_Dimmer_Receiver'), 
  ('ae5609d3c440418c9fa611a5f29ff2c7'::uuid, 'nexa.Nexa_PCR_2300_4_Switch_Receiver'), 
  ('ae6079d7657d4355b30846475423e9cc'::uuid, 'proove.Proove_EWR1003_Switch_Receiver'), 
  ('ae62f5fc8a91452f8eec3fb3e7498062'::uuid, 'proove.Proove_EWT0006_Remote_Control'),
  ('ae6f22fabd604da59395c35bfe51e0d0'::uuid, 'proove.Proove_00180_Switch_Receiver'),
  ('ae782bb134bc4cbf9c77c957fd8a730c'::uuid, 'proove.Proove_00190_Remote_Control'),
  ('ae7ba14e1ded4f65aef38682fd246b9a'::uuid, 'proove.Proove_00179_Dimmer_Receiver'),
  ('ae7c79ef7ff84a1eb8d9a68766a2f943'::uuid, 'proove.Proove_EWR0006_Switch_Receiver'),
  ('ae7e09996cad436fabcd002b29ce74cc'::uuid, 'telldus.Telldus_Tellstick_Duo_TSDUOR_Receiver'),
  ('ae9bc7be4cd0421a85570e247042ef7b'::uuid, 'telldus.Telldus_Tellstick_Duo_TSDUOT_Transmiter'),
  ('aeaf7ce382d24ca78bb104794390a1e4'::uuid, 'gui.Falkenberg_Web_Based_GUI'),
  ('aeb0f8812a314d31811e8ef05e06c342'::uuid, 'gui.TMHH_Web_Based_GUI'),
  ('a80dacb81aed4798a8744f2536810110'::uuid, 'maxim.HCH_MAXIM_ADC')
;

--select select_id_by_name('TMHH_Web_Based_GUI');DROP TABLE IF EXISTS module_communication CASCADE;

CREATE TABLE module_communication
(
	module_communication_id			uuid PRIMARY KEY UNIQUE DEFAULT generate_uuid(),
	name							text,
	description						text DEFAULT '',
	insert_time_stamp				timestamptz NOT NULL DEFAULT clock_timestamp(),	
	insert_by						text NOT NULL DEFAULT CURRENT_USER,
	update_time_stamp				timestamptz NOT NULL DEFAULT clock_timestamp(),
	update_by						text NOT NULL DEFAULT CURRENT_USER
);

CREATE OR REPLACE FUNCTION insert_module_communication( v_name character varying,v_description text ) 
	RETURNS boolean
	LANGUAGE plpgsql 
	VOLATILE	
AS $$
BEGIN 
 INSERT INTO module_communication ( name,description ) 
 VALUES ( v_name,v_description ); 
 RETURN TRUE; 
END; 
$$;

DROP FUNCTION IF EXISTS select_module_communication_id_by_name( v_name varchar );
CREATE OR REPLACE FUNCTION select_module_communication_id_by_name( v_name varchar )
	RETURNS uuid
	LANGUAGE plpgsql 
	VOLATILE	
AS $$
DECLARE 
	_id uuid;
BEGIN
	SELECT module_communication_id INTO STRICT _id
    FROM module_communication
	WHERE LOWER(name) LIKE '%'|| LOWER(v_name) || '%';
	RETURN _id;
EXCEPTION
	WHEN NO_DATA_FOUND THEN
		RAISE EXCEPTION 'No Module Communication with name %.', v_name;
	WHEN TOO_MANY_ROWS THEN
		RAISE EXCEPTION 'Module Communication with name % not unique.', v_name;
END;
$$;

INSERT INTO module_communication ( module_communication_id, name ) 
VALUES 
	( 'a7702e18fd1c4c3a93c13325ac02e5aa'::uuid, 'tellduscore.TelldusCore'),
	( 'a792427b3895439694ebb18c185fb8ef'::uuid, 'serialcomm.SerialComm'),
	( 'ab170b40350545f1ab38ef26fbd7de6e'::uuid, 'sa3l.SA3L'),
	( 'ab1deba1b0ce4ddb854e5993f8e49719'::uuid, 'http.HTTP'),
	( 'a7908da9793d4beca089389c29ba09d5'::uuid, 'spi.maxim')
;
DROP TABLE IF EXISTS module_ipc CASCADE;

CREATE TABLE module_ipc
(
	module_ipc_id					uuid PRIMARY KEY UNIQUE DEFAULT generate_uuid(),
	name							text,
	description						text DEFAULT '',
	insert_time_stamp				timestamptz NOT NULL DEFAULT clock_timestamp(),	
	insert_by						text NOT NULL DEFAULT CURRENT_USER,
	update_time_stamp				timestamptz NOT NULL DEFAULT clock_timestamp(),
	update_by						text NOT NULL DEFAULT CURRENT_USER
);

CREATE OR REPLACE FUNCTION insert_module_ipc( v_name character varying,v_description text ) 
	RETURNS boolean
	LANGUAGE plpgsql 
	VOLATILE	
AS $$
BEGIN 
	INSERT INTO module_ipc ( name,description ) 
	VALUES ( v_name,v_description ); 
	RETURN TRUE; 
END; 
$$;

DROP FUNCTION IF EXISTS select_module_ipc_id_by_name( v_name varchar );
CREATE OR REPLACE FUNCTION select_module_ipc_id_by_name( v_name varchar )
	RETURNS uuid
	LANGUAGE plpgsql 
	VOLATILE	
AS $$
DECLARE 
	_id uuid;
BEGIN
	SELECT module_ipc_id INTO STRICT _id
    FROM module_ipc
	WHERE LOWER(name) LIKE '%'|| LOWER(v_name) || '%';
	RETURN _id;
EXCEPTION
	WHEN NO_DATA_FOUND THEN
		RAISE EXCEPTION 'No Module IPC with name %.', v_name;
	WHEN TOO_MANY_ROWS THEN
		RAISE EXCEPTION 'Module IPC with name % not unique.', v_name;
END;
$$;

INSERT INTO module_ipc ( module_ipc_id, name, description) 
VALUES ( 'aab54b8076594d0bb51910f3e2dd47a4'::uuid, 'pgnotify.PG_Notify', 'Uses PostgreSQL interprocess communication mechanism' );


DROP TABLE IF EXISTS module_storage CASCADE;

CREATE TABLE module_storage
(
	module_storage_id				uuid PRIMARY KEY UNIQUE DEFAULT generate_uuid(),
	name							text,
	description						text DEFAULT '',
	insert_time_stamp				timestamptz NOT NULL DEFAULT clock_timestamp(),	
	insert_by						text NOT NULL DEFAULT CURRENT_USER,
	update_time_stamp				timestamptz NOT NULL DEFAULT clock_timestamp(),
	update_by						text NOT NULL DEFAULT CURRENT_USER
);

CREATE OR REPLACE FUNCTION insert_module_storage( v_name character varying,v_description text ) 
	RETURNS boolean
	LANGUAGE plpgsql 
	VOLATILE	
AS $$ 
BEGIN 
 INSERT INTO module_storage ( name,description ) 
 VALUES ( v_name,v_description ); 
 RETURN TRUE; 
END; 
$$;

DROP FUNCTION IF EXISTS select_module_storage_id_by_name( v_name varchar );
CREATE OR REPLACE FUNCTION select_module_storage_id_by_name( v_name varchar )
	RETURNS uuid
	LANGUAGE plpgsql 
	VOLATILE	
AS $$
DECLARE 
	_id uuid;
BEGIN
	SELECT module_storage_id INTO STRICT _id
    FROM module_storage
	WHERE LOWER(name) LIKE '%'|| LOWER(v_name) || '%';
	RETURN _id;
EXCEPTION
	WHEN NO_DATA_FOUND THEN
		RAISE EXCEPTION 'No Module Storage with name %.', v_name;
	WHEN TOO_MANY_ROWS THEN
		RAISE EXCEPTION 'Module Storage with name % not unique.', v_name;
END;
$$;


INSERT INTO module_storage ( module_storage_id, name ) 
VALUES 
	( 'aaf93b3b78424ea3a13253dbf3ebf347'::uuid, 'postgresql.PostgreSQL')
;
DROP TABLE IF EXISTS trigger_event CASCADE;

CREATE TABLE trigger_event
(
	trigger_event_id				uuid PRIMARY KEY UNIQUE DEFAULT generate_uuid(),
	name 							text,
	description						text DEFAULT '',
	insert_time_stamp				timestamptz NOT NULL DEFAULT clock_timestamp(),	
	insert_by						text NOT NULL DEFAULT CURRENT_USER,
	update_time_stamp				timestamptz NOT NULL DEFAULT clock_timestamp(),
	update_by						text NOT NULL DEFAULT CURRENT_USER
);

DROP FUNCTION IF EXISTS select_trigger_event_id_by_name( v_name varchar );
CREATE OR REPLACE FUNCTION select_trigger_event_id_by_name( v_name varchar )
	RETURNS uuid
	LANGUAGE plpgsql 
	VOLATILE	
AS $$
DECLARE 
	_trigger_event_id uuid;
BEGIN
	SELECT trigger_event_id INTO STRICT _trigger_event_id
    FROM trigger_event
	WHERE LOWER(name) LIKE '%'|| LOWER(v_name) || '%';
	RETURN _trigger_event_id;
EXCEPTION
	WHEN NO_DATA_FOUND THEN
	RAISE EXCEPTION 'No Trigger Event %.', v_name;
	WHEN TOO_MANY_ROWS THEN
	RAISE EXCEPTION 'Trigger Event % not unique.', v_name;
	END;
$$;

INSERT INTO trigger_event ( trigger_event_id, name, description ) 
VALUES 
	('a2557a8b482940df8d99f404cb2db351'::uuid, 'INSERT', 'INSERT creates new rows in a table'),
	('a2557a8b482940df8d99f404cb2db352'::uuid, 'UPDATE', 'UPDATE updates rows of a table'),
	('a2557a8b482940df8d99f404cb2db353'::uuid, 'DELETE', 'DELETE deletes rows of a table'),
	('a2557a8b482940df8d99f404cb2db354'::uuid, 'TRUNCATE', 'TRUNCATE quickly removes all rows from a set of tables')
;

--select select_trigger_event_id_by_name('insert');

DROP TABLE IF EXISTS trigger_timming CASCADE;

CREATE TABLE trigger_timming
(
	trigger_timming_id				uuid PRIMARY KEY UNIQUE DEFAULT generate_uuid(),
	name 							text,
	description						text DEFAULT '',
	insert_time_stamp				timestamptz NOT NULL DEFAULT clock_timestamp(),	
	insert_by						text NOT NULL DEFAULT CURRENT_USER,
	update_time_stamp				timestamptz NOT NULL DEFAULT clock_timestamp(),
	update_by						text NOT NULL DEFAULT CURRENT_USER
);

DROP FUNCTION IF EXISTS select_trigger_timming_id_by_name( v_name varchar );
CREATE OR REPLACE FUNCTION select_trigger_timming_id_by_name( v_name varchar )
	RETURNS uuid
	LANGUAGE plpgsql 
	VOLATILE	
AS $$
DECLARE 
	_trigger_timming_id uuid;
BEGIN
	SELECT trigger_timming_id INTO STRICT _trigger_timming_id
    FROM trigger_timming
	WHERE LOWER(name) LIKE '%'|| LOWER(v_name) || '%';
	RETURN _trigger_timming_id;
EXCEPTION
	WHEN NO_DATA_FOUND THEN
		RAISE EXCEPTION 'No Triggering %.', v_name;
	WHEN TOO_MANY_ROWS THEN
		RAISE EXCEPTION 'Triggering % not unique.', v_name;
	END;
$$;

INSERT INTO trigger_timming ( trigger_timming_id, name, description ) 
VALUES 
	('aa85df1ba5a74a84b0e5ecb76c10ccb1'::uuid, 'AFTER', 'Triggers after an event.'),
	('aa85df1ba5a74a84b0e5ecb76c10ccb2'::uuid, 'BEFORE', 'Triggers before an event.'),
	('aa85df1ba5a74a84b0e5ecb76c10ccb3'::uuid, 'INSTEAD OF', 'Triggers and can skip the event.')
;

--select select_trigger_timming_id_by_name('after');

DROP TABLE IF EXISTS resource_adapter CASCADE;

CREATE TABLE resource_adapter
(
	resource_adapter_id				uuid PRIMARY KEY UNIQUE DEFAULT generate_uuid(),
	module_adapter_id				uuid REFERENCES module_adapter (module_adapter_id) ON DELETE RESTRICT ON UPDATE CASCADE,
	module_communication_id			uuid REFERENCES module_communication (module_communication_id) ON DELETE RESTRICT ON UPDATE CASCADE,
	module_ipc_id					uuid REFERENCES module_ipc (module_ipc_id) ON DELETE RESTRICT ON UPDATE CASCADE,
	module_storage_id				uuid REFERENCES module_storage (module_storage_id) ON DELETE RESTRICT ON UPDATE CASCADE,
	name							text DEFAULT '',
	description						text DEFAULT '',
	insert_time_stamp				timestamptz NOT NULL DEFAULT clock_timestamp(),	
	insert_by						text NOT NULL DEFAULT CURRENT_USER,
	update_time_stamp				timestamptz NOT NULL DEFAULT clock_timestamp(),
	update_by						text NOT NULL DEFAULT CURRENT_USER
);

INSERT INTO resource_adapter (resource_adapter_id, module_adapter_id, module_communication_id, module_ipc_id, module_storage_id, name ) 
VALUES 
  ('abaf8406f79d4bd19faaeb14f571dd73'::uuid, select_module_adapter_id_by_name('ti_ads1232ref'), select_module_communication_id_by_name('serialcomm'), select_module_ipc_id_by_name('pgnotify'), select_module_storage_id_by_name('postgresql'), 'ti_ads1232ref_weight_scale.py'), 
  ('abb0d71e4e6a46199b986085433746e6'::uuid, select_module_adapter_id_by_name('axis_m1013w'), select_module_communication_id_by_name('http.HTTP'), select_module_ipc_id_by_name('pgnotify'), select_module_storage_id_by_name('postgresql'), 'axis_m1013w_network_camera.py'), 
  ('abb35e0b106847669b46fad16a310349'::uuid, select_module_adapter_id_by_name('sca3000'), select_module_communication_id_by_name('serialcomm'), select_module_ipc_id_by_name('pgnotify'), select_module_storage_id_by_name('postgresql'), 'sca3000_accelerometer.py'), 
  ('abb675e1aa2b410c81246366587e11e5'::uuid, select_module_adapter_id_by_name('emfit_bed_l_4060s'), select_module_communication_id_by_name('tellduscore'), select_module_ipc_id_by_name('pgnotify'), select_module_storage_id_by_name('postgresql'), 'emfit_bed_l_4060s.py'), 
  ('abcacc5b8b374ebaabb9fed39dbbfd5d'::uuid, select_module_adapter_id_by_name('esic_wt450h'), select_module_communication_id_by_name('tellduscore'), select_module_ipc_id_by_name('pgnotify'), select_module_storage_id_by_name('postgresql'), 'esic_wt450h_temperatue_humidity.py'), 
  ('abd78528f92045baa8275138fe88746f'::uuid, select_module_adapter_id_by_name('everflourish_emw200ra'), select_module_communication_id_by_name('tellduscore'), select_module_ipc_id_by_name('pgnotify'), select_module_storage_id_by_name('postgresql'), 'everflourish_emw200ra_switch_receiver.py'),
  ('abe23479506d4dc9aa4faed1f5cad1e2'::uuid, select_module_adapter_id_by_name('nexa_eycr_200'), select_module_communication_id_by_name('tellduscore'), select_module_ipc_id_by_name('pgnotify'), select_module_storage_id_by_name('postgresql'), 'nexa_eycr_200_dimmer_receiver.py'), 
  ('abe34fa367e54eb796bdf68f5d5c056d'::uuid, select_module_adapter_id_by_name('nexa_eycr_2300'), select_module_communication_id_by_name('tellduscore'), select_module_ipc_id_by_name('pgnotify'), select_module_storage_id_by_name('postgresql'), 'nexa_eycr_2300_switch_receiver.py'), 
  ('abe717ac6c204c729ed42ca89837b9cd'::uuid, select_module_adapter_id_by_name('nexa_neycr_1500'), select_module_communication_id_by_name('tellduscore'), select_module_ipc_id_by_name('pgnotify'), select_module_storage_id_by_name('postgresql'), 'nexa_neycr_1500_switch_receiver.py'), 
  ('abf2bfe41a4e4770800d7f2d6465203d'::uuid, select_module_adapter_id_by_name('nexa_eycr_250'), select_module_communication_id_by_name('tellduscore'), select_module_ipc_id_by_name('pgnotify'), select_module_storage_id_by_name('postgresql'), 'nexa_eycr_250_dimmer_receiver.py'), 
  ('ac00d0c3b6cc41f4b8e60ba031df7fcb'::uuid, select_module_adapter_id_by_name('nexa_ldr_911_led'), select_module_communication_id_by_name('tellduscore'), select_module_ipc_id_by_name('pgnotify'), select_module_storage_id_by_name('postgresql'), 'nexa_ldr_911_led_white.py'), 
  ('ac0834ff605d493e890ced7384a9beb7'::uuid, select_module_adapter_id_by_name('nexa_ldr_911a_led'), select_module_communication_id_by_name('tellduscore'), select_module_ipc_id_by_name('pgnotify'), select_module_storage_id_by_name('postgresql'), 'nexa_ldr_911a_led_black.py'), 
  ('ac1078f1f8594f6392927e41017efd40'::uuid, select_module_adapter_id_by_name('nexa_lmdt_609'), select_module_communication_id_by_name('tellduscore'), select_module_ipc_id_by_name('pgnotify'), select_module_storage_id_by_name('postgresql'), 'nexa_lmdt_609_pir.py'), 
  ('ac2d7dd8ec274afd99d3ac53b9b429cb'::uuid, select_module_adapter_id_by_name('nexa_lmdt_810'), select_module_communication_id_by_name('tellduscore'), select_module_ipc_id_by_name('pgnotify'), select_module_storage_id_by_name('postgresql'), 'nexa_lmdt_810_out_pir.py'), 
  ('ac37234be53f421bb2bd3e5a685185ab'::uuid, select_module_adapter_id_by_name('nexa_lmlt_711'), select_module_communication_id_by_name('tellduscore'), select_module_ipc_id_by_name('pgnotify'), select_module_storage_id_by_name('postgresql'), 'nexa_lmlt_711_push_button.py'), 
  ('ac41fab7f5c04bea8ddcf60f5f02663e'::uuid, select_module_adapter_id_by_name('nexa_lmst_606'), select_module_communication_id_by_name('tellduscore'), select_module_ipc_id_by_name('pgnotify'), select_module_storage_id_by_name('postgresql'), 'nexa_lmst_606_magnet.py'), 
  ('ac4c3f68fc714a1bb62c41d317a80890'::uuid, select_module_adapter_id_by_name('nexa_lwst_605_2ch'), select_module_communication_id_by_name('tellduscore'), select_module_ipc_id_by_name('pgnotify'), select_module_storage_id_by_name('postgresql'), 'nexa_lwst_605_2ch_wall_switch_transmiter.py'), 
  ('ac5558511dd04cd8ba63d12094ee37aa'::uuid, select_module_adapter_id_by_name('nexa_lwst_615_1ch'), select_module_communication_id_by_name('tellduscore'), select_module_ipc_id_by_name('pgnotify'), select_module_storage_id_by_name('postgresql'), 'nexa_lwst_615_1ch_wall_switch_transmiter.py'), 
  ('ac60e53b29174a8cbd0c5e3b2528ebfd'::uuid, select_module_adapter_id_by_name('nexa_lyct_802'), select_module_communication_id_by_name('tellduscore'), select_module_ipc_id_by_name('pgnotify'), select_module_storage_id_by_name('postgresql'), 'nexa_lyct_802_remote_control.py'), 
  ('ac691f84843e4a28ad63fbc5fcd04021'::uuid, select_module_adapter_id_by_name('nexa_mlr_1105'), select_module_communication_id_by_name('tellduscore'), select_module_ipc_id_by_name('pgnotify'), select_module_storage_id_by_name('postgresql'), 'nexa_mlr_1105_door_bell.py'), 
  ('ac7c44f3360a422886e38ee790321c73'::uuid, select_module_adapter_id_by_name('nexa_lmlr_710'), select_module_communication_id_by_name('tellduscore'), select_module_ipc_id_by_name('pgnotify'), select_module_storage_id_by_name('postgresql'), 'nexa_lmlr_710_door_bell.py'), 
  ('ac9156daf5ab4c21b2e9df9a33e70e9f'::uuid, select_module_adapter_id_by_name('nexa_neyct_705'), select_module_communication_id_by_name('tellduscore'), select_module_ipc_id_by_name('pgnotify'), select_module_storage_id_by_name('postgresql'), 'nexa_neyct_705_remote_control.py'), 
  ('ac9ccbd52da84aadb7a6fc9c31d859fd'::uuid, select_module_adapter_id_by_name('nexa_wmr_252'), select_module_communication_id_by_name('tellduscore'), select_module_ipc_id_by_name('pgnotify'), select_module_storage_id_by_name('postgresql'), 'nexa_wmr_252_dimmer_receiver.py'),
  ('ac9fd9ce5bbb4ac99ac95da48a38ac3a'::uuid, select_module_adapter_id_by_name('nexa_pcr_2300'), select_module_communication_id_by_name('tellduscore'), select_module_ipc_id_by_name('pgnotify'), select_module_storage_id_by_name('postgresql'), 'nexa_pcr_2300_4_switch_receiver.py'),
  ('aca98fef64d747619d546c7cd128da1c'::uuid, select_module_adapter_id_by_name('proove_ewr1003'), select_module_communication_id_by_name('tellduscore'), select_module_ipc_id_by_name('pgnotify'), select_module_storage_id_by_name('postgresql'), 'proove_ewr1003_switch_receiver.py'), 
  ('acc2c0e4716748f9b07efbb294756dfb'::uuid, select_module_adapter_id_by_name('proove_ewt0006'), select_module_communication_id_by_name('tellduscore'), select_module_ipc_id_by_name('pgnotify'), select_module_storage_id_by_name('postgresql'), 'proove_ewt0006_remote_control.py'),
  ('acccfec28ac44bcabc119e9daf53a91d'::uuid, select_module_adapter_id_by_name('proove_00180'), select_module_communication_id_by_name('tellduscore'), select_module_ipc_id_by_name('pgnotify'), select_module_storage_id_by_name('postgresql'), 'proove_00180_switch_receiver.py'),
  ('acdafd3b374141979de7b4a753205c4e'::uuid, select_module_adapter_id_by_name('proove_00190'), select_module_communication_id_by_name('tellduscore'), select_module_ipc_id_by_name('pgnotify'), select_module_storage_id_by_name('postgresql'), 'proove_00190_remote_control.py'),
  ('acee1f9cd9d34356bc87b893a445391a'::uuid, select_module_adapter_id_by_name('proove_00179'), select_module_communication_id_by_name('tellduscore'), select_module_ipc_id_by_name('pgnotify'), select_module_storage_id_by_name('postgresql'), 'proove_00179_dimmer_receiver.py'),
  ('acfa771c75b8433bb496bbeb360c2fdd'::uuid, select_module_adapter_id_by_name('proove_ewr0006'), select_module_communication_id_by_name('tellduscore'), select_module_ipc_id_by_name('pgnotify'), select_module_storage_id_by_name('postgresql'), 'proove_ewr0006_switch_receiver.py'),
  ('ad03b00fc4f54686968903bd44a89a11'::uuid, select_module_adapter_id_by_name('tsduor'), select_module_communication_id_by_name('tellduscore'), select_module_ipc_id_by_name('pgnotify'), select_module_storage_id_by_name('postgresql'), 'telldus_tellstick_duo_tsduor_receiver.py'),
  ('ad06e6928001426e90808b01aedae169'::uuid, select_module_adapter_id_by_name('tsduot'), select_module_communication_id_by_name('tellduscore'), select_module_ipc_id_by_name('pgnotify'), select_module_storage_id_by_name('postgresql'), 'telldus_tellstick_duo_tsduot_transmiter.py'),
  ('ad082b173fb94a18a6f7c480e14eedb3'::uuid, select_module_adapter_id_by_name('falkenberg_web_based_gui'), select_module_communication_id_by_name('http.HTTP'), select_module_ipc_id_by_name('pgnotify'), select_module_storage_id_by_name('postgresql'), 'falkenberg_web_based_gui'),
  ('abab6ec920dd4b42a5482f8679732bd4'::uuid, select_module_adapter_id_by_name('tmhh_web_based_gui'), select_module_communication_id_by_name('http.HTTP'), select_module_ipc_id_by_name('pgnotify'), select_module_storage_id_by_name('postgresql'), 'tmhh_web_based_gui'),
  ('a8488065e2f341a0b7c04de8ed09c3b0'::uuid, select_module_adapter_id_by_name('HCH_MAXIM_ADC'), select_module_communication_id_by_name('spi.maxim'), select_module_ipc_id_by_name('pgnotify'), select_module_storage_id_by_name('postgresql'), 'hch_maxim_adc')
;


CREATE OR REPLACE FUNCTION insert_resource_adapter( v_module_adapter_id integer,v_module_communication_id integer,v_module_ipc_id integer,v_module_storage_id integer,v_name character varying,v_description text ) 
	RETURNS boolean
	LANGUAGE plpgsql 
	VOLATILE	
AS $$ 
BEGIN 
	INSERT INTO resource_adapter ( module_adapter_id,module_communication_id,module_ipc_id,module_storage_id,name,description ) 
	VALUES ( v_module_adapter_id,v_module_communication_id,v_module_ipc_id,v_module_storage_id,v_name,v_description ); 
	RETURN TRUE; 
END; 
$$;

DROP FUNCTION IF EXISTS select_resource_adapter_by_name( v_name varchar );
CREATE OR REPLACE FUNCTION select_resource_adapter_by_name( v_name varchar )
	RETURNS TABLE(resource_adapter_id integer, name varchar, description text) 
	LANGUAGE plpgsql 
	VOLATILE	
AS $$
BEGIN
	RETURN QUERY SELECT T.resource_adapter_id, T.name, T.description
    FROM resource_adapter T
	WHERE LOWER(T.name) LIKE '%'|| LOWER(v_name) || '%';
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RAISE EXCEPTION 'No Resource Adapter with name %.', v_name;
END;
$$;
-- select select_resource_adapter_by_name('sensor');

DROP FUNCTION IF EXISTS select_resource_adapter_id_by_name( v_name varchar );
CREATE OR REPLACE FUNCTION select_resource_adapter_id_by_name( v_name varchar )
	RETURNS uuid
	LANGUAGE plpgsql 
	VOLATILE	
AS $$
DECLARE 
	_id uuid;
BEGIN
	SELECT resource_adapter_id INTO STRICT _id
    FROM resource_adapter
	WHERE LOWER(name) LIKE '%'|| LOWER(v_name) || '%';
	RETURN _id;
EXCEPTION
	WHEN NO_DATA_FOUND THEN
		RAISE EXCEPTION 'No Resource Adapter with name %.', v_name;
	WHEN TOO_MANY_ROWS THEN
		RAISE EXCEPTION 'Resource Adapter with name % not unique.', v_name;
END;
$$;
-- select select_id_by_name('sensor');


DROP TABLE IF EXISTS resource_model CASCADE;

CREATE TABLE resource_model
(
	resource_model_id				uuid PRIMARY KEY UNIQUE DEFAULT generate_uuid(),
	name							text,
	description						text DEFAULT '',
	attributes						jsonb DEFAULT '[]'::jsonb,	
	insert_time_stamp				timestamptz NOT NULL DEFAULT clock_timestamp(),	
	insert_by						text NOT NULL DEFAULT CURRENT_USER,
	update_time_stamp				timestamptz NOT NULL DEFAULT clock_timestamp(),
	update_by						text NOT NULL DEFAULT CURRENT_USER
);


INSERT INTO resource_model ( resource_model_id, name, attributes ) 
VALUES 
  ('aeb294078d6f46c6847e3ac04e25024c'::uuid, 'TI ADS1232REF Weight Scale', '[]'::jsonb),
  ('aebb29b0a43b4f6caa115f547594b155'::uuid, 'Axis m1013w Network Camera', '[]'::jsonb),
  ('aebfe03b5aca487d96a3a5c67bbeeb99'::uuid, 'sca3000 Accelerometer', '[]'::jsonb),
  ('aecd9d57443b4f36bcd69dd339d67b35'::uuid, 'Emfit Bed L-4060s', '[]'::jsonb),
  ('aed25ad41e0c4160b6f04c15c39b273e'::uuid, 'ESIC WT450H Temperatue Humidity', '[]'::jsonb),
  ('aed941877d72472c98c5a7975ab0e31c'::uuid, 'Everflourish EMW200RA Switch Receiver', '[]'::jsonb),
  ('aee52526ce7644b895bf7ef87f103b55'::uuid, 'Nexa EYCR-200 Dimmer Receiver', '[{"table_sufix": "","attributes": "sample integer"}]'),
  ('aeef25f4f7eb4f6b851fd14430723be3'::uuid, 'Nexa EYCR-2300 Switch Receiver', '[{"table_sufix": "","attributes": "sample bool"}]'),
  ('aeefa7f9c97848acab6fd93b341ac371'::uuid, 'Nexa NEYCR-1500 Switch Receiver', '[{"table_sufix": "","attributes": "sample bool"}]'),
  ('aeface07311e40a3b47c980565a7852f'::uuid, 'Nexa EYCR-250 Dimmer Receiver', '[{"table_sufix": "","attributes": "sample integer"}]'),
  ('af07759a097b47268f0a046435c33033'::uuid, 'Nexa LDR-911 Led White', '[{"table_sufix": "","attributes": "sample bool"}]'),
  ('af159312c0e1488c910eaa063d715747'::uuid, 'Nexa LDR-911A Led Black', '[{"table_sufix": "","attributes": "sample bool"}]'),
  ('af1ca3c3a06a40caa0c57718ee3dcaec'::uuid, 'Nexa LMDT-609 PIR', '[{"table_sufix": "","attributes": "sample bool"}]'),
  ('af26ff8df783440495b28137e94e0cff'::uuid, 'Nexa LMDT-810 OUT PIR', '[{"table_sufix": "","attributes": "sample bool"}]'),
  ('af2a8c0725a54497b19c846b8355cdc6'::uuid, 'Nexa LMLT-711 Push Button', '[{"table_sufix": "","attributes": "sample integer"}]'),
  ('af3d7ae3c4044070afeab3a69f2198e5'::uuid, 'Nexa LMST-606 Magnet', '[{"table_sufix": "","attributes": "sample bool"}]'),
  ('af440e5f02634d1c9a22074af14dbb86'::uuid, 'Nexa LWST-605 2Ch Wall Switch Transmiter', '[{"table_sufix": "","attributes": "sample bool, unit integer"}]'),
  ('af4767120d9f4b85be7b2331952fd0df'::uuid, 'Nexa LWST-615 1Ch Wall Switch Transmiter', '[{"table_sufix": "","attributes": "sample bool"}]'),
  ('af5efb8647164eba97e66af054cc07f3'::uuid, 'Nexa LYCT-802 Remote Control', '[]'::jsonb),
  ('af6a4004959c469f9213c7c71d4bea34'::uuid, 'Nexa MLR-1105 Door Bell', '[{"table_sufix": "","attributes": "sample bool"}]'),
  ('af7f8881889647f8a3e64891ab7becf7'::uuid, 'Nexa LMLR-710 Door Bell', '[{"table_sufix": "","attributes": "sample bool"}]'),
  ('af90475fb18542a7929a346879867d6c'::uuid, 'Nexa NEYCT-705 Remote Control', '[]'::jsonb),
  ('af94cef5054b4315ac5c535ff60b708a'::uuid, 'Nexa WMR-252 Dimmer Receiver', '[{"table_sufix": "","attributes": "sample integer"}]'),
  ('afa1cadac56f4f28a7408b0455181a33'::uuid, 'Nexa PCR-2300 4 Switch Receiver', '[{"table_sufix": "","attributes": "sample bool"}]'),
  ('afb323b51c18471ca7e3ab8b1d4e6abf'::uuid, 'Proove EWR1003 Switch Receiver', '[{"table_sufix": "","attributes": "sample bool"}]'),
  ('afb3c44ceb6445fc895dae90a9e4368f'::uuid, 'Proove EWT0006 Remote Control', '[]'::jsonb),
  ('afbc0482206b4a2bac9070393bb314e1'::uuid, 'Proove 00180 Switch Receiver', '[{"table_sufix": "","attributes": "sample bool"}]'),
  ('afc275bf24284c458227d35119451334'::uuid, 'Proove 00190 Remote Control', '[]'::jsonb),
  ('afc6a707cd664f85b5db67fbc53bc018'::uuid, 'Proove 00179 Dimmer Receiver', '[{"table_sufix": "","attributes": "sample integer"}]'),
  ('afd6e74e32c54f73896148d24fd28a29'::uuid, 'Proove EWR0006 Switch Receiver', '[{"table_sufix": "","attributes": "sample integer"}]'),
  ('afd8fe334e2641c5b5090325259d3cab'::uuid, 'Telldus Tellstick Duo TSDUOR Receiver', '[{"table_sufix": "","attributes": "sample bool"}]'),
  ('afe42246ce48488a9fd697909b303e45'::uuid, 'Telldus Tellstick Duo TSDUOT Transmiter', '[{"table_sufix": "","attributes": "sample bool"}]'),
  ('afe4df6a0f124dd78914fd0c69d256d5'::uuid, 'Falkenberg Web Based GUI', '[]'::jsonb),
  ('a7ad68adbda242e5a8503410f44f0319'::uuid, 'HCH Maxim ADC', '[{"table_sufix": "","attributes": ["weight numeric, bedttime timestamptz, getuptime timestamptz, timeinbed interval, movratio numeric, nobedexits integer, nonaps integer"]}, {"table_sufix": "weight","attributes": ["weight numeric"]},{"table_sufix": "in_bed","attributes": ["inbed bool, duration interval DEFAULT ''00:00:00''::interval"]}, {"table_sufix": "movement","attributes": ["movement bool, duration interval DEFAULT ''00:00:00''::interval"]}]'),
  ('aff9b100efb44a9988195e31ffcc4426'::uuid, 'TMHH Web Based GUI', '[]'::jsonb)
;


CREATE OR REPLACE FUNCTION insert_resource_model( v_name character varying, v_description text, v_attributes jsonb ) 
	RETURNS boolean
	LANGUAGE plpgsql 
	VOLATILE	
AS $$
BEGIN 
	INSERT INTO resource_model ( name, description, attributes ) 
	VALUES ( v_name, v_description, v_attributes ); 
	RETURN TRUE; 
END; 
$$;

DROP FUNCTION IF EXISTS select_resource_model_by_name( v_name varchar );
CREATE OR REPLACE FUNCTION select_resource_model_by_name( v_name varchar )
	RETURNS TABLE(resource_model_id uuid, name varchar, description text) 
	LANGUAGE plpgsql 
	VOLATILE	
AS $$
BEGIN
	RETURN QUERY 
		SELECT T.resource_model_id, T.name, T.description
		FROM resource_model T
		WHERE LOWER(T.name) LIKE '%'|| LOWER(v_name) || '%';
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RAISE EXCEPTION 'No Resource Model with name %.', v_name;
END;
$$;
--select select_resource_model_by_name('LMDT-810');

DROP FUNCTION IF EXISTS select_resource_model_id_by_name( v_name varchar );
CREATE OR REPLACE FUNCTION select_resource_model_id_by_name( v_name varchar )
RETURNS uuid 
	LANGUAGE plpgsql 
	VOLATILE	
AS $$
DECLARE 
	_id uuid;
BEGIN
	SELECT resource_model_id INTO STRICT _id
    FROM resource_model
	WHERE LOWER(name) LIKE '%'|| LOWER(v_name) || '%';
	RETURN _id;
	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			RAISE EXCEPTION 'No Resource Model with name %.', v_name;
		WHEN TOO_MANY_ROWS THEN
			RAISE EXCEPTION 'Resource Model with name % not unique.', v_name;
END;
$$;
--select select_id_by_name('LMDT-810');
DROP TABLE IF EXISTS resource_type CASCADE;

CREATE TABLE resource_type
(
	resource_type_id				uuid PRIMARY KEY UNIQUE DEFAULT generate_uuid(),
	name							text,
	description						text DEFAULT '',
	insert_time_stamp				timestamptz NOT NULL DEFAULT clock_timestamp(),	
	insert_by						text NOT NULL DEFAULT CURRENT_USER,
	update_time_stamp				timestamptz NOT NULL DEFAULT clock_timestamp(),
	update_by						text NOT NULL DEFAULT CURRENT_USER
);

CREATE OR REPLACE FUNCTION insert_resource_type( v_name character varying,v_description text ) 
	RETURNS boolean
	LANGUAGE plpgsql 
	VOLATILE	
AS $$
BEGIN 
 INSERT INTO resource_type ( name,description ) 
 VALUES ( v_name,v_description ); 
 RETURN TRUE; 
END; 
$$;

DROP FUNCTION IF EXISTS select_resource_type_by_name( v_name varchar );
CREATE OR REPLACE FUNCTION select_resource_type_by_name( v_name varchar )
	RETURNS TABLE(resource_type_id uuid, name varchar, description text)
	LANGUAGE plpgsql 
	VOLATILE	
AS $$
BEGIN
	RETURN QUERY SELECT T.resource_type_id, T.name, T.description
    FROM resource_type T
	WHERE LOWER(T.name) LIKE '%'|| LOWER(v_name) || '%';
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RAISE EXCEPTION 'No Resource Type with name %.', v_name;
END;
$$;

DROP FUNCTION IF EXISTS select_resource_type_id_by_name( v_name varchar );
CREATE OR REPLACE FUNCTION select_resource_type_id_by_name( v_name varchar )
	RETURNS uuid 
	LANGUAGE plpgsql 
	VOLATILE	
AS $$
DECLARE 
	_id uuid;
BEGIN
	SELECT resource_type_id INTO STRICT _id
    FROM resource_type
	WHERE name=v_name;
	RETURN _id;
EXCEPTION
	WHEN NO_DATA_FOUND THEN
		RAISE EXCEPTION 'No Resource Type with name %.', v_name;
	WHEN TOO_MANY_ROWS THEN
		RAISE EXCEPTION 'Resource Type with name % not unique.', v_name;
END;
$$;

INSERT INTO resource_type ( resource_type_id, name, description  ) 
VALUES 
	('ab38ee65116f476990bd956ddaaa26e3'::uuid, 'Sensor', 'Provides sensing capabilities' ), 
	('ab44a8168ea4433f87238247b03c811c'::uuid, 'Actuator', 'Provides actuation capabilities' ), 
	('ab46f4b8bfef451e9c624b5855d352d6'::uuid, 'Mechatronic system', 'Provides sensing and actuation capabilities' ),
	('ab48701043c2420485a836743a63e019'::uuid, 'API', 'Software libraries providing an application programming interfaces for a given resource (eg MS SAPI)' ),
	('ab2709d6fe02457d9b0dcd567fb607f0'::uuid, 'GUI', 'Graphical User Interfaces (eg a web app on a smart phone)' )
;

-- select select_id_by_name('sensor');
-- select select_resource_type_by_name('sensor');
DROP TABLE IF EXISTS experiment CASCADE;

CREATE TABLE resident
(
	resident_id						uuid PRIMARY KEY UNIQUE DEFAULT generate_uuid(),
	first_name						text,
	last_name						text,
	female							boolean DEFAULT true,
	weight							numeric DEFAULT 0,
	weight_upper_limit				numeric DEFAULT 0,
	weight_lower_limit				numeric DEFAULT 0,
	tib_upper_limit					timetz,
	tib_lower_limit					timetz,
	movement_upper_limit			numeric DEFAULT 0,
	bedtime							timetz,
	bedtime_upper_limit				timetz,
	bedtime_lower_limit				timetz,
	gut								timetz,
	gut_upper_limit					timetz,
	gut_lower_limit					timetz,
	night_bex						integer DEFAULT 0,
	night_bex_upper_limit			integer DEFAULT 0,
	night_bex_lower_limit			integer DEFAULT 0,
	naps_upper_limit				integer DEFAULT 0,
	naps_lower_limit				integer DEFAULT 0,
	insert_time_stamp				timestamptz NOT NULL DEFAULT clock_timestamp(),	
	insert_by						text NOT NULL DEFAULT CURRENT_USER,
	update_time_stamp				timestamptz NOT NULL DEFAULT clock_timestamp(),
	update_by						text NOT NULL DEFAULT CURRENT_USER
);

CREATE OR REPLACE FUNCTION insert_resident( v_resident_id uuid, v_first_name character varying, 
		v_last_name character varying, v_female boolean, v_weight numeric, v_weight_upper_limit numeric, 
		v_weight_lower_limit numeric, v_tib_upper_limit timetz, v_tib_lower_limit timetz, v_movement_upper_limit numeric, 
		v_bedtime timetz, v_bedtime_upper_limit timetz, v_bedtime_lower_limit timetz, v_gut timetz, v_gut_upper_limit timetz, 
		v_gut_lower_limit timetz, v_night_bex integer, v_night_bex_upper_limit integer, v_night_bex_lower_limit integer, 
		v_naps_upper_limit integer, v_naps_lower_limit integer ) 		
	RETURNS boolean
	LANGUAGE plpgsql 
	VOLATILE
AS $$ 
BEGIN 
	INSERT INTO resident(
            resident_id, first_name, last_name, female, weight, weight_upper_limit, 
            weight_lower_limit, tib_upper_limit, tib_lower_limit, movement_upper_limit, 
            bedtime, bedtime_upper_limit, bedtime_lower_limit, gut, gut_upper_limit, 
            gut_lower_limit, night_bex, night_bex_upper_limit, night_bex_lower_limit, 
            naps_upper_limit, naps_lower_limit)
    VALUES (
			v_resident_id, v_first_name, v_last_name, v_female, v_weight, v_weight_upper_limit, 
			v_weight_lower_limit, v_tib_upper_limit, v_tib_lower_limit, v_movement_upper_limit, 
			v_bedtime, v_bedtime_upper_limit, v_bedtime_lower_limit, v_gut, v_gut_upper_limit, 
			v_gut_lower_limit, v_night_bex, v_night_bex_upper_limit, v_night_bex_lower_limit, 
			v_naps_upper_limit, v_naps_lower_limit);
	RETURN TRUE; 
END; 
$$;

DROP FUNCTION IF EXISTS select_resident( v_uuid uuid );
CREATE OR REPLACE FUNCTION select_resident( v_uuid uuid ) 
	RETURNS  TABLE(	first_name character varying, last_name character varying, female boolean, weight numeric, weight_upper_limit numeric, 
			weight_lower_limit numeric, tib_upper_limit timetz, tib_lower_limit timetz, movement_upper_limit numeric, 
			bedtime timetz, bedtime_upper_limit timetz, bedtime_lower_limit timetz, gut timetz, gut_upper_limit timetz, 
			gut_lower_limit timetz, night_bex integer, night_bex_upper_limit integer, night_bex_lower_limit integer, 
			naps_upper_limit integer, naps_lower_limit integer )
	LANGUAGE plpgsql 
	VOLATILE
AS $$ 
BEGIN
	RETURN QUERY SELECT T.first_name, T.last_name, T.female, T.weight, T.weight_upper_limit, 
						T.weight_lower_limit, T.tib_upper_limit, T.tib_lower_limit, T.movement_upper_limit, 
						T.bedtime, T.bedtime_upper_limit, T.bedtime_lower_limit, T.gut, T.gut_upper_limit, 
						T.gut_lower_limit, T.night_bex, T.night_bex_upper_limit, T.night_bex_lower_limit, 
						T.naps_upper_limit, T.naps_lower_limit
    FROM resident T
	WHERE T.resident_id = v_uuid;
END;
$$;
DROP TABLE IF EXISTS resource CASCADE;
CREATE TABLE resource
(
	resource_uuid					uuid PRIMARY KEY UNIQUE DEFAULT generate_uuid(),
	resource_type_id				uuid REFERENCES resource_type (resource_type_id) ON DELETE RESTRICT ON UPDATE CASCADE,	
	resource_model_id				uuid REFERENCES resource_model (resource_model_id) ON DELETE RESTRICT ON UPDATE CASCADE,
	resource_adapter_id				uuid REFERENCES resource_adapter (resource_adapter_id) ON DELETE RESTRICT ON UPDATE CASCADE,
	name							text DEFAULT '',
	description						text DEFAULT '',
	string_config					jsonb DEFAULT '[]'::jsonb,
	default_udf						text DEFAULT '',
	auto_start						boolean DEFAULT false,
	keep_connected					boolean DEFAULT false,
	host_ip							inet DEFAULT NULL,
	insert_time_stamp				timestamptz NOT NULL DEFAULT clock_timestamp(),	
	insert_by						text NOT NULL DEFAULT CURRENT_USER,
	update_time_stamp				timestamptz NOT NULL DEFAULT clock_timestamp(),
	update_by						text NOT NULL DEFAULT CURRENT_USER
);

---------------FUNCTIONS------------------------------------------------------------
CREATE OR REPLACE FUNCTION insert_resource( v_resource_uuid uuid, v_resource_type_id uuid, v_resource_model_id uuid, v_resource_adapter_id uuid, v_name text, v_description text, v_string_config jsonb, v_auto_start boolean, v_keep_connected boolean, v_host_ip inet ) 
	RETURNS boolean
	LANGUAGE plpgsql 
	VOLATILE	
AS $$
DECLARE 
	_default_udf varchar := 'insert_' || replace(v_resource_uuid::text, '-', '');
BEGIN
	INSERT INTO resource ( resource_uuid, resource_type_id, resource_model_id, resource_adapter_id, name, description, string_config, default_udf, auto_start, keep_connected, host_ip ) 
	VALUES ( v_resource_uuid, v_resource_type_id, v_resource_model_id, v_resource_adapter_id, v_name, v_description, v_string_config, _default_udf, v_auto_start, v_keep_connected, _host_ip ); 
	RETURN TRUE; 
END; 
$$;

CREATE OR REPLACE FUNCTION insert_resource( v_resource_uuid uuid, v_resource_type text, v_resource_model text, v_resource_adapter text, v_name text, v_description text, v_string_config jsonb, v_auto_start boolean, v_keep_connected boolean, v_host_ip inet ) 
	RETURNS boolean
	LANGUAGE plpgsql 
	VOLATILE	
AS $$
DECLARE 
	_default_udf varchar := 'insert_' || replace(v_resource_uuid::text, '-', '');
	v_resource_type_id uuid := select_resource_type_id_by_name(v_resource_type);
	v_resource_model_id uuid := select_resource_model_id_by_name(v_resource_model);
	v_resource_adapter_id uuid := select_resource_adapter_id_by_name(v_resource_adapter);
BEGIN
	INSERT INTO resource ( resource_uuid, resource_type_id, resource_model_id, resource_adapter_id, name, description, string_config, default_udf, auto_start, keep_connected, host_ip ) 
	VALUES ( v_resource_uuid, v_resource_type_id, v_resource_model_id, v_resource_adapter_id, v_name, v_description, v_string_config, _default_udf, v_auto_start, v_keep_connected, v_host_ip ); 
	RETURN TRUE; 
END; 
$$;

CREATE OR REPLACE FUNCTION insert_resource( v_resource_type_id uuid, v_resource_model_id uuid, v_resource_adapter_id uuid, v_name text, v_description text, v_string_config jsonb, v_auto_start boolean, v_keep_connected boolean, v_host_ip inet ) 
	RETURNS boolean
	LANGUAGE plpgsql 
	VOLATILE	
AS $$
DECLARE 
	_default_udf varchar := 'insert_' || replace(v_resource_uuid::text, '-', '');
	_uuid uuid;
BEGIN
	SELECT generate_uuid() into _uuid;
	INSERT INTO resource ( resource_uuid, resource_type_id, resource_model_id, resource_adapter_id, name, description, string_config, default_udf, auto_start, keep_connected, host_ip ) 
	VALUES ( _uuid, v_resource_type_id, v_resource_model_id, v_resource_adapter_id, v_name, v_description, v_string_config, _default_udf, v_auto_start, v_keep_connected, v_host_ip ); 
	RETURN TRUE; 
END; 
$$;

CREATE OR REPLACE FUNCTION select_resource_config( v_uuid uuid ) 
	RETURNS TABLE(resource_uuid text, name varchar, string_config jsonb, default_udf varchar, auto_start boolean, keep_connected boolean )
	LANGUAGE plpgsql 
	VOLATILE	
AS $$	
BEGIN
	RETURN QUERY SELECT replace(R.resource_uuid::text, '-', ''), R.name, R.string_config, R.default_udf, R.auto_start, R.keep_connected
    FROM resource R
	WHERE R.resource_uuid = v_uuid;
END;
$$;

CREATE OR REPLACE FUNCTION select_resources_by_model( v_model varchar )
	RETURNS TABLE(resource_uuid uuid, name varchar, description text)
	LANGUAGE plpgsql 
	VOLATILE	
AS $$	
BEGIN
	RETURN QUERY SELECT r.resource_uuid, r.name, r.description
	FROM resource r
	WHERE r.resource_model_id = select_resource_model_id_by_name(v_model);
	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			RAISE EXCEPTION 'No Resource(s) found.';
END;
$$;
--select * from select_resources_by_model('HCH Maxim ADC');
	
---------------TRIGGERS------------------------------------------------------------
--######################
--# TRIGGER AFTER INSERT
--######################
DO $$ BEGIN
  EXECUTE get_sql_stmt_create_trigger( 'resource', 'resource', 'after', 'insert', '',
  'BEGIN
     PERFORM create_resource_db_objects(new.resource_uuid, new.resource_model_id);
	 RETURN NULL;
   END;
  ');  
END $$;

--######################
--# TRIGGER AFTER DELETE
--######################  

DO $$ BEGIN
  EXECUTE get_sql_stmt_create_trigger( 'resource', 'resource', 'after', 'delete', '',
  'BEGIN
	PERFORM delete_resource_db_objects(old.resource_uuid);
	RETURN NULL;
  END;'
  );  
END $$;

DROP TABLE IF EXISTS notification CASCADE;

CREATE TABLE notification
(
	channel							text,
	message							text CHECK (char_length(message) <= 8000),
	acknowledged 					timestamptz DEFAULT NULL,
	insert_time_stamp				timestamptz DEFAULT clock_timestamp() PRIMARY KEY,	
	insert_by						text NOT NULL DEFAULT CURRENT_USER
);

---------------FUNCTIONS------------------------------------------------------------

DROP FUNCTION IF EXISTS insert_notification( v_channel character varying, v_message text ); 
CREATE OR REPLACE FUNCTION insert_notification( v_channel character varying, v_message text ) 
	RETURNS boolean
	LANGUAGE plpgsql 
	VOLATILE
AS $$ 
BEGIN 
	INSERT INTO notification ( channel, message ) 
	VALUES ( v_channel, v_message ); 
	RETURN TRUE; 
END; 
$$;

DROP FUNCTION IF EXISTS acknowledge_notification( v_channel varchar); 
CREATE OR REPLACE FUNCTION acknowledge_notification( v_channel varchar ) 
	RETURNS boolean
	LANGUAGE plpgsql 
	VOLATILE
AS $$ 
BEGIN
	UPDATE notification SET acknowledged = v_dev_ts
	WHERE insert_time_stamp = (
								SELECT distinct on (channel) insert_time_stamp
								FROM notification
								WHERE channel = v_channel AND acknowledged is null
								ORDER BY channel, insert_time_stamp DESC
							);
	RETURN TRUE;        
END;
$$;

---------------TRIGGERS------------------------------------------------------------
--######################
--# after_insert_notification
--######################
DO $$ BEGIN
	EXECUTE get_sql_stmt_create_trigger( 'notification', 'notification', 'after', 'insert', '',
		'BEGIN
			EXECUTE FORMAT(''NOTIFY %1$I, ''''%2$s'''''', NEW.channel, NEW.message);
			RETURN NULL;
		END;
	');    
END $$;


  DROP TABLE IF EXISTS resource_location CASCADE;

CREATE TABLE resource_location
(
	resource_uuid					uuid REFERENCES resource(resource_uuid) ON DELETE RESTRICT ON UPDATE CASCADE,
	room_id							uuid REFERENCES room(room_id) ON DELETE RESTRICT ON UPDATE CASCADE,
	insert_time_stamp				timestamptz NOT NULL DEFAULT clock_timestamp(),	
	insert_by						text NOT NULL DEFAULT CURRENT_USER,
	PRIMARY KEY (resource_uuid, room_id, insert_time_stamp)
);

CREATE OR REPLACE FUNCTION insert_resource_location( v_resource_uuid uuid, v_room_id uuid ) 
	RETURNS boolean
	LANGUAGE plpgsql 
	VOLATILE
AS $$ 
BEGIN 
	INSERT INTO resource_location ( resource_uuid, room_id ) 
	VALUES ( v_resource_uuid, v_room_id); 
	RETURN TRUE; 
END; 
$$;

DROP FUNCTION IF EXISTS select_location_id_by_resource_id( v_resource_uuid uuid );
CREATE OR REPLACE FUNCTION select_location_id_by_resource_id( v_resource_uuid uuid )
	RETURNS uuid
	LANGUAGE plpgsql 
	VOLATILE
AS $$ 
DECLARE 
	_id uuid;
BEGIN
	SELECT room_id INTO STRICT _id
    FROM resource_location
	WHERE resource_uuid = v_resource_uuid;
	RETURN _id;
EXCEPTION
	WHEN NO_DATA_FOUND THEN
		RAISE EXCEPTION 'No location for the given resource %.', v_resource_uuid::text;
END;
$$;

DROP FUNCTION IF EXISTS select_location_by_resource_id( v_resource_uuid uuid );
CREATE OR REPLACE FUNCTION select_location_by_resource_id( v_resource_uuid uuid )
	RETURNS varchar
	LANGUAGE plpgsql 
	VOLATILE
AS $$ 
DECLARE 
	_location varchar;
BEGIN
	SELECT room.name INTO STRICT _location
    FROM room 
    INNER JOIN resource_location
        ON room.room_id = resource_location.room_id and resource_location.resource_uuid = v_resource_uuid;
	RETURN _location;
EXCEPTION
	WHEN NO_DATA_FOUND THEN
		RAISE EXCEPTION 'No location for the given resource %.', v_resource_uuid::text;
END;
$$;


DROP TABLE IF EXISTS resource_resident CASCADE;

CREATE TABLE resource_resident
(
	resource_uuid					uuid REFERENCES resource(resource_uuid) ON DELETE RESTRICT ON UPDATE CASCADE,
	resident_id						uuid REFERENCES resident(resident_id) ON DELETE RESTRICT ON UPDATE CASCADE,
	insert_time_stamp				timestamptz NOT NULL DEFAULT clock_timestamp(),	
	insert_by						text NOT NULL DEFAULT CURRENT_USER,
	PRIMARY KEY (resource_uuid, resident_id, insert_time_stamp)
);

CREATE OR REPLACE FUNCTION insert_resource_resident( v_resource_uuid uuid, v_resident_id uuid ) 
	RETURNS boolean
	LANGUAGE plpgsql 
	VOLATILE
AS $$ 
BEGIN 
	INSERT INTO resource_resident ( resource_uuid, resident_id ) 
	VALUES ( v_resource_uuid, v_resident_id); 
	RETURN TRUE; 
END; 
$$;

CREATE OR REPLACE FUNCTION select_resource_by_resident( v_resident_id uuid ) 
	RETURNS uuid
	LANGUAGE plpgsql 
	VOLATILE
AS $$ 
DECLARE 
	_id uuid;
BEGIN 
	SELECT resource_uuid INTO STRICT _id
	FROM resource_resident
	WHERE resident_id = v_resident_id;
	RETURN _id; 
END; 
$$;

CREATE OR REPLACE FUNCTION select_resident_by_resource( v_resource_uuid uuid ) 
RETURNS uuid
	LANGUAGE plpgsql 
	VOLATILE
AS $$ 
DECLARE 
	_id uuid;
BEGIN 
	SELECT resident_id INTO STRICT _id
	FROM resource_resident
	WHERE resource_uuid = v_resource_uuid;
	RETURN _id; 
END; 
$$;



DROP TABLE IF EXISTS resource_status CASCADE;

CREATE TABLE resource_status
(
	resource_uuid					uuid REFERENCES resource(resource_uuid) ON DELETE RESTRICT ON UPDATE CASCADE,
	status_type						status_type DEFAULT 'Not Available'::status_type,
	insert_time_stamp				timestamptz NOT NULL DEFAULT clock_timestamp(),	
	insert_by						text NOT NULL DEFAULT CURRENT_USER,
	PRIMARY KEY (resource_uuid, status_type, insert_time_stamp)
);

CREATE OR REPLACE FUNCTION insert_resource_status( v_resource_uuid uuid, v_status_type status_type ) 
	RETURNS boolean
	LANGUAGE plpgsql 
	VOLATILE
AS $$ 
BEGIN 
	INSERT INTO resource_status ( resource_uuid, status_type ) 
	VALUES ( v_resource_uuid, v_status_type  ); 
	RETURN TRUE; 
END; 
$$;


DROP TABLE IF EXISTS resource_trigger CASCADE;

DROP TABLE IF EXISTS resource_trigger;
CREATE TABLE resource_trigger
(
	resource_uuid					uuid REFERENCES resource (resource_uuid) ON DELETE RESTRICT ON UPDATE CASCADE,
	trigger_timming_id				uuid REFERENCES trigger_timming (trigger_timming_id) ON DELETE RESTRICT ON UPDATE CASCADE,
	trigger_event_id				uuid REFERENCES trigger_event (trigger_event_id) ON DELETE RESTRICT ON UPDATE CASCADE,
	code							text,
	active							bool,
	insert_time_stamp				timestamptz NOT NULL DEFAULT clock_timestamp(),	
	insert_by						text NOT NULL DEFAULT CURRENT_USER,
	update_time_stamp				timestamptz NOT NULL DEFAULT clock_timestamp(),
	update_by						text NOT NULL DEFAULT CURRENT_USER,
	PRIMARY KEY (resource_uuid, trigger_timming_id, trigger_event_id, insert_time_stamp)
);

---------------FUNCTIONS------------------------------------------------------------
--######################
--# insert_resource_trigger
--######################
DROP FUNCTION IF EXISTS insert_resource_trigger( v_resource_uuid uuid, v_trigger_timming_id uuid, v_trigger_event_id uuid, v_code text, v_active boolean ); 
CREATE OR REPLACE FUNCTION insert_resource_trigger( v_resource_uuid uuid, v_trigger_timming_id uuid, v_trigger_event_id uuid, v_code text, v_active boolean ) 
	RETURNS boolean
	LANGUAGE plpgsql 
	VOLATILE
AS $$  
BEGIN 
	 INSERT INTO resource_trigger ( resource_uuid, trigger_timming_id, trigger_event_id, code, active ) 
	 VALUES ( v_resource_uuid, v_trigger_timming_id, v_trigger_event_id, v_code, v_active ); 
	 RETURN TRUE; 
END; 
$$; 

DROP FUNCTION IF EXISTS insert_resource_trigger( v_resource_uuid uuid, v_trigger_timming varchar, v_trigger_event varchar, v_code text, v_active boolean ); 
CREATE OR REPLACE FUNCTION insert_resource_trigger( v_resource_uuid uuid, v_trigger_timming varchar, v_trigger_event varchar, v_code text, v_active boolean ) 
	RETURNS boolean
	LANGUAGE plpgsql 
	VOLATILE
AS $$ 
DECLARE
	v_trigger_timming_id uuid := select_trigger_timming_id_by_name(v_trigger_timming);
	v_trigger_event_id uuid := select_trigger_event_id_by_name(v_trigger_event);	
BEGIN 
	 INSERT INTO resource_trigger ( resource_uuid, trigger_timming_id, trigger_event_id, code, active ) 
	 VALUES ( v_resource_uuid, v_trigger_timming_id, v_trigger_event_id, v_code, v_active ); 
	 RETURN TRUE; 
END; 
$$;

---------------TRIGGERS------------------------------------------------------------
--######################
--# after_insert_resource_trigger
--######################
DO $$ BEGIN
	EXECUTE get_sql_stmt_create_trigger( 'resource_trigger', 'resource_trigger', 'after', 'insert', '',
	'BEGIN
		IF (NEW.resource_uuid IS NOT NULL) THEN
			IF (NEW.active) THEN
				PERFORM create_resource_after_insert_trigger(NEW.resource_uuid, NEW.code);
			END IF;	
		END IF;	   	 
		RETURN NULL;
	END;
	');  
END $$;

--######################
--# after_update_resource_trigger
--######################
DO $$ BEGIN
	EXECUTE get_sql_stmt_create_trigger( 'resource_trigger', 'resource_trigger', 'after', 'update', '',
	'BEGIN
		IF (NEW.resource_uuid IS NOT NULL) THEN
			IF (NEW.active) THEN
				PERFORM create_resource_after_insert_trigger(OLD.resource_uuid, NEW.code);
			ELSE
				PERFORM drop_resource_after_insert_trigger(OLD.resource_uuid);
			END IF;	
		END IF;	   	 
		RETURN NULL;
	END;
	');  
END $$;


--######################
--# before_delete_resource_trigger
--######################
  
DO $$ BEGIN
	EXECUTE get_sql_stmt_create_trigger( 'resource_trigger', 'resource_trigger', 'before', 'delete', '',
	'BEGIN
		IF (NEW.resource_uuid IS NOT NULL) THEN
			PERFORM drop_resource_after_insert_trigger(OLD.resource_uuid);
		END IF;	   	 
		RETURN NULL;
	END;
	');  
END $$;  

-- REVOKE ALL PRIVILEGES ON DATABASE dbname FROM PUBLIC;
-- REVOKE ALL PRIVILEGES ON SCHEMA schemaname FROM public;
-- CREATE ROLE username WITH LOGIN PASSWORD '...';
-- GRANT CONNECT ON DATABASE dbname TO username;
-- GRANT EXECUTE ON FUNCTION <x(), y() TO username;
-- ALTER USER username WITH ENCRYPTED PASSWORD 'password';
-- GRANT ALL PRIVILEGES ON DATABASE dbname to username ;
-- REVOKE ALL ON ALL TABLES IN SCHEMA public FROM PUBLIC;
-- GRANT SELECT, INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA public TO user_name;
-- GRANT CONNECT ON DATABASE dbname TO username;
-- ALTER DEFAULT PRIVILEGES FOR ROLE rolename IN SCHEMA public GRANT SELECT, INSERT, UPDATE, DELETE ON TABLES TO username;
-- ALTER DEFAULT PRIVILEGES FOR USER username IN SCHEMA public GRANT SELECT, INSERT, UPDATE, DELETE ON TABLES TO username;

-- REVOKE ALL PRIVILEGES ON DATABASE dbname FROM PUBLIC;
-- REVOKE ALL PRIVILEGES ON ALL TABLES IN SCHEMA schemaname FROM public;
-- REVOKE ALL PRIVILEGES ON ALL FUNCTIONS IN SCHEMA schemaname FROM public;
-- REVOKE ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA schemaname FROM public;
-- REVOKE CONNECT ON DATABASE dbname FROM PUBLIC;

-- CREATE USER username WITH PASSWORD 'password' VALID UNTIL '2018-04-01';
-- GRANT CONNECT ON DATABASE dbname TO username;


--ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT SELECT, INSERT, UPDATE, DELETE ON tables TO user_name;
--ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT SELECT, USAGE ON sequences TO user_name;

SELECT 'SUCCESS'::text as Status; 
